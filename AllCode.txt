Final Code submission, Edward Speer, EE/CS10b Spring '23

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                                                                         ;
;                          				      HEXER GAME                                                  ;
;                          			       Functional Specification                                           ;
;                                                             EE/CS 10b                                                   ;
;                                                                                                                         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


  Description:  	The system is a Hexer game in which the user uses 5 switches to attempt to manipulate  
			the game configuration displayed on LEDs into the winning configuration via 5 legal moves.
			There is 7 segment display for indicating the current move number, and reset switches which
			allow both manual reset to a given configuration or game reset to a random configuration. 
			On game start there is a speaker which begins playing game music, and upon winning the game, 
			the speaker switches to a different song and display blinks. In order to win the game, the user 
			manipulates the game board via the 5 legal moves until all of the LEDs in the 15 LED display
			are turned ON.

  Global Variables:	GameBoard - The configuration of the game board at any time throughout the game play.


  Inputs:                All user input occurs through 6 switches:
			 _________________________________________________________________________________________
                        |  Switch Name  |  Switch Type  |                        Description                      |
			|---------------|---------------|---------------------------------------------------------|
			|     START     |  Pushbutton   | Used to start a new game. Must be held down while one of|
			|		|		| either "Random Reset", "Manual Reset 1", or "Manual     |
			|		|		| Reset 0" is selected to indicate whether a random or    |
			|		|		| custom configuration is desired.			  |
			|---------------|---------------|---------------------------------------------------------|
			|   Move 1 /    |  Pushbutton   | When pressed during game play, this switch executes an  |
			|    (White)	|        	| inversion of the inner hexagon on the game board, i.e   |
			|               |		| inversion of the states of LEDs 3, 4, 7, 9, 12, and 13. |
			|		|		|							  |
			|---------------|---------------|---------------------------------------------------------|
			|   Move 2 /    |  Pushbutton   | When pressed during game play, this switch executes a   |
			|  Random Reset |		| clockwise rotation of the right hexagon on the game     |
			|    (Black)    |		| board consisting of LEDs 4, 5, 10, 14, 13, and 8        |
			|		|		|							  |
			|		|		| When pressed while the START switch is held, this switch|
			|		|		| causes the move number to reset and the LEDs to take on |
			|		|		| a random configuration.				  |
			|---------------|---------------|---------------------------------------------------------|
			|   Move 3 /    |  Pushbutton   | When pressed during game play, this switch executes a   |  
			| Manual Reset 1|		| counterclockwise rotation of the states of the left     |
			|    (Blue)     |		| hexagon in the game board, consisting of LEDS 2, 3, 8,  |
			|		|		| 12, 11, and 6.					  |
			|		|		|							  |
			|		|		| When pressed while the START button is held, this switch|
			|		|		| shifts an ON LED into the game configuration, which acts|
			|		|		| as a shift register in manual reset mode.		  |
			|---------------|---------------|---------------------------------------------------------|
			|    Move 4     |  Pushbutton   | When pressed, this switch executes a clockwise rotation |
			|     (Red)     |		| of the upper triangle in the game board, consisting of  |
			|		|		| LEDS 1, 4, 9, 14, 13, 12, 11, 7, and 3.                 |
			|---------------|---------------|---------------------------------------------------------|
			|   Move 5/     |  Pushbutton   | When pressed this switch executes a counterclockwise    |
			| Manual Reset 0|		| rotation of the lower triangle in the game board,       |
			|    (Green)	|		| consisting of LEDs 2, 3, 4, 5, 9, 13, 15, 12, and 7.    |
			|		|		|							  |
			|		|		| When pressed while the START switch is held, this switch|
			|		|		| resets the move number, and shifts a 0 into the game LED|
			|		|		| board, with all LEDs treated as a shift register.       |
			|_______________|_______________|_________________________________________________________|


  Outputs:		4-digit 7-segment display:  Displays the current number of moves used by the player in
						    attempting to solve the puzzle since last resetting using the 
						    START button.

			15-LED display:             Displays the state of the current game board. Flashes when the 
						    user has solved the puzzle and won the game.

			Speaker:                    Plays game music throughout the game place (Star Trek theme 
                                                    music), then upon winning, plays the Mario Stage Win music 
						    until the user resets the game, then returns to the game play
						    music until the user wins again. 
			

  User Interface: 	The current game state is displayed on the 15 LEDs. The current number of moves used by 
			the player is displayed on the 4-digit 7 segment LED display. The user can use any of the 5
			switches corresponding to moves to manipulate the LED's in the game state as described above
			in "inputs". At any time, the user may reset the game state and the moves counter by holding  
			the START button, and pressing one of the random or manual reset switches. When these are 
                        pressed at the same time as the start switch they will reset the game as described in the 
                        "inputs" section above. Any time a user wins the game, they are informed of their victory 
			by the blinking of the game board LEDs and the playing of stage win music.

  Error Handling:	If there is a power failure, the system will reset to a psuedo-random configuration of the
			game board, with the 4-digit display showing 0 moves.

			If a player presses the START button but does not select one of either the "Random Reset"
			or the "Manual Reset _" switches, then the button will have no effect. The 4 digit display
			and 15 LED displays will continue to display the data of the current game session.

			If the move number used by the player overflows the 4 digit display, the system automatically 
			resets the move counter back to 0.

			The system's switches must be appropriately debounced so that inconsistencies in the 
			hardware do not cause any disruption or change in game control that users do not intend.


  Limitations:		If a player uses more moves than are able to fit in the 4 digit display (9999), the game must 
			reset, so that there is a limit to the number of moves that a game session can be played 
			for.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                  HEXER.ASM                                 ;
;                            Main Method Game Code                           ;
;                                  EE/CS 10b                                 ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This program sets up the interrupt table for the system, calls all hardward 
; and variables initialization, and then starts up the game loop for the 
; Microprocessor-based Hexer game
;
; Public Routines - None
;
;
; Revision History:
;    5/20/23   Edward Speer        initial revision
;    6/3/23    Edward Speer        Update for speaker code
;    6/13/23   Edward Speer        Update for game main code
;    6/16/23   Edward Speer        Finalize comments

;set the device
.device	ATMEGA64

;get the definitions for the device
.include  "m64def.inc"

;include all the .inc files since all .asm files are needed here (no linker)
.include  "swtch.inc"
.include  "disp.inc"
.include  "hexer.inc"
.include  "speaker.inc"
.include  "sound.inc"
.include  "moves.inc"

.cseg

;setup the vector area

.org	$0000

	JMP	Start			;reset vector
	JMP	PC			;external interrupt 0
	JMP	PC			;external interrupt 1
	JMP	PC			;external interrupt 2
	JMP	PC			;external interrupt 3
	JMP	PC			;external interrupt 4
	JMP	PC			;external interrupt 5
	JMP	PC			;external interrupt 6
	JMP	PC			;external interrupt 7
	JMP	PC			;timer 2 compare match
	JMP	PC			;timer 2 overflow
	JMP	PC			;timer 1 capture
	JMP	PC			;timer 1 compare match A
	JMP	PC			;timer 1 compare match B
	JMP	PC			;timer 1 overflow
	JMP	HexerTimerInterrupt          ;timer 0 compare match (1 ms)
	JMP	PC		    ;timer 0 overflow
	JMP	PC			;SPI transfer complete
	JMP	PC			;UART 0 Rx complete
	JMP	PC			;UART 0 Tx empty
	JMP	PC			;UART 0 Tx complete
	JMP	PC			;ADC conversion complete
	JMP	PC			;EEPROM ready
	JMP	PC			;analog comparator
	JMP	PC			;timer 1 compare match C
	JMP	PC			;timer 3 capture
	JMP	PC     			;timer 3 compare match A
	JMP	PC			;timer 3 compare match B
	JMP	PC			;timer 3 compare match C
	JMP	PC			;timer 3 overflow
	JMP	PC			;UART 1 Rx complete
	JMP	PC			;UART 1 Tx empty
	JMP	PC			;UART 1 Tx complete
	JMP	PC			;Two-wire serial interface
	JMP	PC			;store program memory ready


; start of the actual program


Start:					         ;start the CPU after a reset
	LDI	R16, LOW(TopOfStack)	 ;initialize the stack pointer
	OUT	SPL, R16
	LDI	R16, HIGH(TopOfStack)
	OUT	SPH, R16


	;initialization of the system
	;initialize I/O ports and timer
    ;Initialize variables for system

    RCALL InitSwitchIO          ;Initialize switch IO port as input
    RCALL InitMsTimer           ;Generate timer interrupts every milisecond
    RCALL SpeakerIOInit         ;Set speaker IO port to output
    RCALL InitSpeaker           ;Initialize speaker off
    RCALL InitSoundVars         ;Initialize sound playing variables
    RCALL LEDBoardInit          ;Initialize display ports as outputs
    RCALL InitSwitchVars        ;Initialize switch debugging variables
    SEI				;ready to go, allow interrupts

    RCALL PlayGame Test         ;Run the game main loop

    RJMP Start			 ;shouldn't return, but if it does, restart

;the data segment

.dseg

; the stack - 128 bytes
		.BYTE	127
TopOfStack:	.BYTE	1		     ;top of the stack

;Current game board

GameBoard:  .BYTE   2            ;The current game board given in order: 
                         ;[9, 1, 5, _, 10, 4, 3, 2, 13, 11, 8, 15, 14, 12, 7, 6]




; since don't have a linker, include all the .asm files
;.include "file.asm"

.include "hardware_init.asm"     ;IO/Timer setup routines
.include "speaker.asm"           ;Speaker routines
.include "utils.asm"             ;General utility functions
.include "sound.asm"             ;Sound playing routines
.include "irq.asm"               ;Timer0 interrupt handler
.include "disp.asm"              ;Display functions
.include "segtable.asm"          ;Segment definitions for 7 seg display 
.include "loop.asm"              ;Game main loop 
.include "switches.asm"          ;Switch debouncing functions
.include "moves.asm"             ;Functions enabling users to make moves

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                  HEXER.INC                                 ;
;                                 Definitions                                ;
;                       Microprocessor-Based Hexer Game                      ;
;                                 Include File                               ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the general hardware and constants definitions for the
; Microprocessor-Based Hexer game.
;
; Revision History:
;     5/19/23    Edward Speer    initial revision
;     5/20/23    Edward Speer    Debug IO constants
;     6/13/23    Edward Speer    Add switch patterns 
;     6/13/23    Edward Speer    Add move number digit masks
;     6/15/23    Edward Speer    Add win conditions constants
;     6/15/23    Edward Speer    Update comments and constant names

; IO port definitions
.EQU     READ     = 0b00000000       ;IO input mode select 
.EQU     OUTP     = 0b11111111       ;IO output mode select
.EQU     OCR_OUT  = 0b00100000       ;Output select on OCR1A bit on port B

;Timer controls
.EQU    TIMERCLK32 = 0b01000011      ;Timer0 runs at clock / 32
.EQU    OUTC       = 0b11111010      ;Register for timer output compare
.EQU    TIMSKEN    = 0b00000010      ;Enable timer0 generated interrupts

;Switch Patterns 
.EQU    WHITE_S    = 0b01110110      ;Switch pattern for white switch pressed 
.EQU    BLACK_S    = 0b01011110      ;Switch pattern for black switch pressed 
.EQU    BLUE_S     = 0b01111100      ;Switch pattern for blue switch pressed 
.EQU    RED_S      = 0b01101110      ;Switch pattern for red switch pressed 
.EQU    GREEN_S    = 0b01111010      ;Switch pattern for green switch pressed 
.EQU    RAND_S     = 0b00011110      ;Switch pattern for random start switch 
.EQU    RESET_0    = 0b00111010      ;Switch pattern for reset 0 pressed 
.EQU    RESET_1    = 0b00111100      ;Switch pattern for reset 1 pressed     

;LED Patterns
.EQU   WIN_BOARD_LOW = 0b11111111    ;GameBoard when game is won
.EQU   WIN_BOARD_HIGH= 0b11101111
.EQU   ALL_ON_LOW    = 0b11111111    ;Mask to remove bit 12 from an LED pattern
.EQU   ALL_ON_HIGH   = 0b11101111

;Move number digit masks
.EQU  LOW_DIGIT   = 0b00001111       ;Bit positions right digit in hex number
.EQU  HIGH_DIGIT  = 0b11110000       ;Bit positions of left digit in hex number

.EQU  HEX_09      = 0x09             ;Decimal value 9 in hex
.EQU  HEX_90      = 0x90             ;Decimal value 90 in hex
.EQU  HEX_01      = 0x01             ;Decimal 01 to be added to a hex number 
.EQU  HEX_10      = 0x10             ;Decimal 10 to be added to a hex number

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                   LOOP.ASM                                 ;
;                                Game Main Loop                              ;
;                 Microprocessor-Based Hexer Game (AVR version)              ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the routine which is the main loop allowing the user to 
; play the microprocessor-based hexer game. This loop starts up the game, 
; takes in user input, and responds accordingly. There is also a function for 
; incrementing a 3 digit hex number by 1 to increment the user move number.
;
; Public Routines: PlayGame - Run the main loop of the game which accepts user 
;                             inputs, sets and resets the game conditions,
;                             triggers UI components (sound/display), and 
;                             checks win conditions
;                  IncMoveNum - Increments a decimal value stored as a 16 bit 
;                               hex number by 1 (i.e 0x09 -> 0x10)
;
; Revision History:
;     6/13/23   Edward Speer    Initial Revision
;     6/14/23   Edward Speer    Fix conflicts with functions changing registers
;     6/14/23   Edward Speer    Add game and win music 
;     6/15/23   Edward Speer    Hold on win until reset 
;     6/15/23   Edward Speer    Add display blinking on win
;     6/15/23   Edward Speer    Update comments 


.cseg

; PlayGame
;
; Description:        This procedure is the main loop for the hexer game. In 
;                     the loop, the user input is taken from the switches and 
;                     the game state updated, then the game state is displayed. 
;                     At the appropriate times, the speaker plays sounds.
;
; Operation:          The loop continually gets debounced user input from the
;                     switches, then alters the local versions of the game state 
;                     variables. These are then passed to the display. 
;                     After any move by the user, check if the game is won and 
;                     if so, inform the user of their score.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    GameBoard - a 16 bit mask indicating for each LED if it is
;                                 on or off. The bits in the mask give the game
;                                 LEDs in the following order:
;                         [9, 1, 5, _, 10, 4, 3, 2, 13, 11, 8, 15, 14, 12, 7, 6]
; Shared Variables:   None
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: ZL, ZH, R16, R17, R6, R7, R8, R9, R11, R12 
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

PlayGame:

        RCALL  PlayStartupSound      ;Begin playing the game sound

RandomReset:

        RCALL  ClearDisplay      ;Ensure game board blank to begin with
		RCALL  StopBlink         ;And that board is not blinking
        RCALL  Random16No12      ;Generate a random game board in R9|R8
        LDI    ZL, LOW(GameBoard)
        LDI    ZH, HIGH(GameBoard)
        ST     Z+, R16           ;Store random game board to memory 
        ST     Z, R17
        CLR    R7 
        CLR    R6                ;Set R7|R6 to 0 to use as move number counter 

GameLoop:
        
        MOV    R16, R6
        MOV    R17, R7 
        RCALL  DisplayHex        ;Display number of moves made on 7 seg display
        PUSH   R6                ;Save user move number since registers changed 
        PUSH   R7                ; in other function calls 
        
        LDI    ZL, LOW(GameBoard)
        LDI    ZH, HIGH(GameBoard)
        LD     R16, Z+ 
        LD     R17, Z            ;Load current game board to R17|R16
        RCALL  DisplayGameLEDs   ;Display the current game board

        LDI    R18, WIN_BOARD_LOW
        LDI    R19, WIN_BOARD_HIGH
        CP     R18, R16          ;Compare gameboard with win condition
        BRNE   NextMove          ;If low bytes not equal, get next user move 
        ;BREQ  CheckWin          ;Otherwise check if user has won game 

CheckWin:

        CP     R19, R17 
        BREQ   GameWon           ;If GameBoard is winning board, respond to win
        ;BRNE  NextMove          ;Otherwise, get next user move

NextMove:
 
        RCALL  GetSwitches       ;Get next user switch pattern in R16 

CheckWhite:                      ;Check if white switch pressed 

        
		LDI    R17, WHITE_S
        CP     R16, R17
        BRNE   CheckBlack        ;If white not pressed, check black 
        ;BREQ  WhitePressed      ;Otherwise, respond to white switch 

WhitePressed:

       RCALL   MoveWhite        ;Invert white LEDs 
       RJMP    MoveMade         ;Move finished, go to increment move number 

CheckBlack:

        LDI    R17, BLACK_S
        CP     R16, R17
        BRNE   CheckBlue         ;if black not pressed, check blue 
        ;BREQ  BlackPressed      ;Otherwise respond to black switch

BlackPressed:

        RCALL  MoveBlack         ;Rotate black hexagon
        RJMP   MoveMade          ;Move finished, go to increment move number 

CheckBlue:

        LDI    R17, BLUE_S
        CP     R16, R17
        BRNE   CheckRed          ;if blue not pressed, check red  
        ;BREQ  BluePressed      ;Otherwise respond to blue switch

BluePressed:

        RCALL  MoveBlue          ;Rotate blue hexagon
        RJMP   MoveMade          ;Move finished, go to increment move number

CheckRed:

        LDI    R17, RED_S
        CP     R16, R17
        BRNE   CheckGreen        ;if red not pressed, check green 
        ;BREQ  RedPressed      ;Otherwise respond to red switch

RedPressed:

        RCALL  MoveRed           ;Rotate red triangle
        RJMP   MoveMade          ;Move finished, go to increment move number

CheckGreen:

        LDI    R17, GREEN_S
        CP     R16, R17
        BRNE   CheckRand         ;if green not pressed, check random reset  
        ;BREQ  GreenPressed      ;Otherwise respond to green switch

GreenPressed:

        RCALL  MoveGreen         ;Rotate green triangle
        RJMP   MoveMade          ;Move finished, go to increment move number

CheckRand:

        LDI    R17, RAND_S 
        CP     R16, R17
        BREQ   RandomReset        ;If random reset pressed, perform random reset
        ;BRNE   Check_R_0         ;if random reset not pressed check reset_0

Check_R_0:

        LDI    R17, RESET_0 
        CP     R16, R17 
        BRNE   Check_R_1         ;if reset_0 not pressed, check reset 1
        ;BREQ   DoReset_0           ;Otherwise perform reset_0 

DoReset_0:

        RCALL  MoveReset0
        POP    R7
        POP    R6                ;Clear former move number from stack 
        CLR    R7 
        CLR    R6                ;Reset move counter
        RJMP   GameLoop          ;Repeat game loop


Check_R_1:

        LDI    R17, RESET_1
        CP     R16, R17 
        BRNE   GameLoop          ;if reset_0 not pressed, no switches so restart
                                 ; loop 
        ;BREQ   DoReset_1        ;Otherwise perform reset_0

DoReset_1:

        RCALL  MoveReset1
        POP    R7
        POP    R6                ;Clear former move number from stack 
        CLR    R7 
        CLR    R6                ;Reset move counter
        RJMP   GameLoop          ;Repeat game loop

MoveMade:
        
		POP    R7                ;Restore user move counter
		POP    R6
        RCALL  IncMoveNum        ;Move made, so increment move counter 
        RJMP   GameLoop          ;After move, repeat game loop

GameWon:
        
        RCALL  PlayWinSound      ;Game won so play winning sound
		RCALL  StartBlink        ;And blink the display

WaitForReset:

        RCALL  GetSwitches       ;Wait for a switch press
		LDI    R17, RAND_S
		CP     R16, R17
		BRNE   WaitReset_0       ;If random reset not pressed, check manual
		RCALL  PlayStartupSound  ;Game restarted; play game music
		RJMP   RandomReset       ;Otherwise do random reset

WaitReset_0:

        LDI    R17, RESET_0
		CP     R16, R17
		BRNE   WaitForReset      ;If switch press not reset 0, wait for another switch
		;BREQ  Restar0           ;Otherwise, restart with shifted in 0
		RCALL  PlayStartupSound  ;Game restarted, play game music
		RCALL  MoveReset0        ;shift a 0 into the display
		RCALL  StopBlink         ;Game restarted so stop blinking

        RJMP   GameLoop          ;Initialize game with new config


;IncMoveNum
;
; Description:        This procedure increments a 4 digit decimal number stored 
;                     in hex by 1.
;
; Operation:          Look at each digit in reverse order of significance until
;                     least significant digit which is not a 9 is found, then
;                     increments that digit and sets all previous digits to 0.
;
; Arguments:          16 bits of decimal number stored as hex in R7|R6
; Return Value:       16 bit incremented decimal number as hex in R7|R6
;
; Local Variables:    None
;                     
; Shared Variables:   None
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R6, R7, R16, R17
; 
; Author:             Edward Speer
; Last Modified:      6/13/23

IncMoveNum:

        MOV    R16, R6
        LDI    R17, LOW_DIGIT
        AND    R16, R17          ;Get the ones place digit from the number 
        LDI    R17, HEX_09       
        CP     R16, R17
        BRNE   IncOnes           ;If ones place not 9, increment ones place 
        ;BREQ  CheckTens         ;Otherwise, check the tens place

CheckTens:
        
        MOV    R16, R6 
        LDI    R17, HIGH_DIGIT
        AND    R6, R17           ;Ones place was 9, so set one's place to 0
        AND    R16, R17          ;Get the tens place digit from the number
        LDI    R17, HEX_90 
        CP     R16, R17
        BRNE   IncTens           ;If the tens place not 9, increment tens place
        ;BREQ  CheckHunds        ;Otherwise check hundreds place 

CheckHunds:

        MOV    R16, R7
        LDI    R17, LOW_DIGIT 
        AND    R6, R17           ;Tens place was 9, so set tens to 0 
        AND    R16, R17          ;Get hundreds place from number 
        LDI    R17, HEX_09       
        CP     R16, R17 
        BRNE   IncHunds          ;If hundreds place not 9, then increment it 
        ;BREQ  CheckThous        ;Otherwsise, check thousands place 

CheckThousands:

        MOV    R16, R7 
        LDI    R17, HIGH_DIGIT 
        AND    R7, R17           ;Thousands place was 9, so set it to 0 
        AND    R16, R17          ;Get thousands digit from number 
        LDI    R17, HEX_90 
        CP     R16, R17 
        BRNE   IncThous          ;If thousands place not 9, then increment it 
        ;BREQ  ClearAll          ;If overflowed 4 digit decimal, reset to 0 

ClearAll:

        CLR    R7                ;Ones, tens, hundreds already 0, clear thousands 
        RJMP   Incremented       ;And done

IncOnes:

        LDI    R17, HEX_01 
        ADD    R6, R17           ;Add 1 to the ones place 
        RJMP  Incremented        ;And done 

IncTens: 

        LDI    R17, HEX_10 
        ADD    R6, R17           ;Add 1 to tens place       
        RJMP   Incremented       ;And done

IncHunds:

        LDI    R17, HEX_01 
        ADD    R7, R17           ;Add 1 to hundreds place 
        RJMP   Incremented       ;And done 

IncThous:

        LDI    R17, HEX_10
        ADD    R7, R17           ;Add 1 to thousands place 
        RJMP   Incremented       ;And return 

Incremented:

        RET                      ;Done incrementing, so return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                   IRQ.ASM                                  ;
;                               Interrupt Code                               ;
;                 Microprocessor-Based Hexer Game (AVR version)              ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the timer generated interrupt event handler for the
; Microprocessor-based hex game. The event handler handles both the display 
; multiplexing as well as the switch debouncing for the Hexer game. 
;
; Revision History:
;     6/13/23   Edward Speer    Initial Revision
;     6/13/23   Edward Speer    Add sound to interrupt handling 
;     6/14/23   Edward Speer    Debug register usage in interrupts
;     6/15/23   Edward Speer    Update comments

.cseg

; HexerTimerInterrupt
;
; Description:        This procedure is an event handler for the timer interrupt 
;                     used to display Hexer game data on the 2 game board
;                     displays, to debounce the switch presses input by the 
;                     user, and to play game sounds on the speaker
;
; Operation:          Upon each milisecond clock interrupt, this handler is 
;                     called, and it makes subsequent calls to the routines
;                     which are intended to be called per milisecond for the 
;                     switch, sound, and display code.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   None
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: None
; 
; Author:             Edward Speer
; Last Modified:      6/14/23

HexerTimerInterrupt:

        PUSH   R20              ;Save touched registers 
        IN     R20, SREG        ;And the status register
        PUSH   R20 

        RCALL  DebounceSwitch   ;Debounce user switch presses 
        RCALL  DisplayInterrupt ;Display current data on LEDs/Display 
        RCALL  SoundInterrupt   ;Play current sounds on speaker

        POP    R20
        OUT    SREG, R20        ;Restore status register 
        POP    R20              ;And restore touched registers 
       
        RETI                    ;And done, so return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                   DISP.ASM                                 ;
;                              Display Functions                             ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the functions necessary to display game data on the two 
; multiplexed displays for the user interface of the microprocessor based 
; Hexer game.
;
; Public Routines: InitDisplay - Initializes the variables used for display  
;                                multiplexing. Must be called before displaying 
;                                anything on the board for the first time. 
;                  StartBlink  - Causes the 15 LED display to begin blinking
;                  StopBlink   - Causes the 15 LED display to stop blinking 
;                  BlinkDisplay- Called each ms intterupt to set the state of
;                                the LED to on or off at the appropriate times 
;                                when display blinking. 
;                  DisplayInterrupt - Called each 1 ms timer interrupt to 
;                                     perform display multiplexing
;                  ClearDisplay- Turns off all LEDs in the game board 
;                  DisplayHex  - Displays the 4 digit hex number passed into 
;                                R17|R16 on the 7 segment display 
;                  DisplayGameLEDs - Displays the 16 bit game board mask passed
;                                    into R17|R16 on the 15 LED display
;                  
;
; Revision History:
;     5/19/23   Edward Speer    Initial Revision
;     5/20/23   Edward Speer    Add code for display routines 
;     5/20/23   Edward Speer    Debug display muxing
;     5/20/23   Edward Speer    Update comments
;     6/13/23   Edward Speer    Update DisplayInterrupt for master event handler
;     6/15/23   Edward Speer    Add blinking of the GameBoard LEDs 
;     6/15/23   Edward Speer    Finalize comments 

.cseg


; InitDisplay
;
; Description:        This procedure initializes the variables used for display 
;                     multiplexing
;
; Operation:          Resets the Multiplexing counter to the number of output 
;                     options for the display mux and wipes the buffer using 
;                     ClearDisplay.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   CurMuxDigPat (W) - The pattern of the selected digit
;                     CurMuxDig (W)    - The display mux digit selected
;                     IsBlinking (W)   - Flag indicating if display blinking 
;                     BlinkCount (W)   - The counter used to time blinking
;                     DispOff (W)      - Flag indicating if diaplsy currently off
;                     
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

InitDisplay:

    CLR    R16               ;Store zero as index of the first elem in buffer
    STS    CurMuxDig, R16    ;Initialize current digit to the first activated

    LDI    R16, INIT_PATT 
    STS    CurMuxDigPat, R16 ;Store the drive pattern of the first digit
	
	LDI    R16, NBLINKING
	STS    IsBlinking, R16   ;Display not blinking initially

	LDI    R16, BL_TIME
	STS    BlinkCount, R16   ;Init blink counter to blinking time

	LDI    R16, FALSE
	STS    DispOff, R16      ;Display not initially off

    RCALL  ClearDisplay      ;Initialize display buffer to empty (all LEDS off)
                                       
    RET                      ;Done, so return


;StartBlink
;
; Description:        This procedure is called to cause the 15 LED GameBoard 
;                     display to begin blinking.
;
; Operation:          Sets the blinking flag high so the display will blink
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   IsBlinking (W): A flag indicating the display is blinking
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  R16 
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

StartBlink:

        LDI    R16, BLINKING
		STS    IsBlinking, R16        ;Set blinking flag on
		RET


;StopBlink
;
; Description:        This procedure is called to cause the display to stop 
;                     blinking
;
; Operation:          Sets the blinking flag high so the display will not blink
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   IsBlinking (W): Is a flag indicating the display is blinking
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  R16
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

StopBlink:

        LDI    R16, NBLINKING
		STS    IsBlinking, R16        ;Set blinking flag on
		RET


;BlinkDisplay
;
; Description:        This procedure is called by the event handler for the 
;                     timer interrupts generated each milisecond on the Hexer 
;                     system, and is used to blink the gameboard display when
;                     the BlinkDisplay flag is set.
;
; Operation:          On every clock interrupt, this routine is called, and
;                     based on a counter, determines whether the display
;                     LEDs should shwo the current GameBoard, or should all be 
;                     off if the display is blinking. If the display is not 
;                     blinking, does nothing. Toggles the state of the LEDs 
;                     every time the counter reaches 0.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:   
; Shared Variables:   IsBlinking (R): Is a flag indicating the display is blinking
;                     BlinkCounter (R/W): The counter used to blink the display
;                     DispOff (R/W): Flag indicating if display is currently off
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  R16, R17, R18
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

BlinkDisplay:

        LDS    R16, IsBlinking     ;Check if the display is blinking
		LDI    R17, BLINKING
		CP     R16, R17
		BRNE   DoneBlinking        ;If not, nothing to do
		;BREQ  DoBlink             ;Otherwise, perform blinking

DoBlink:

        LDS    R18, BlinkCount
		DEC    R18
		BRNE   StoreBCount         ;If the blink counter non-zero, just decrement
		;BREQ  ChangeDisp          ;Otherwise, swap state of LEDs

ChangeDisp:

        LDS    R16, DispOff
		TST    R16
		BRNE   BoardOn             ;If LEDS previously off, set to game board
		;BREQ  ResetCount          ;Otherwise reset counter

ResetCount:

        LDI    R18, BL_TIME        ;If counter was 0, reset to blink time

BoardOff:

        LDI    R16, LEDSOFF
		LDI    R17, LEDSOFF
		RCALL  DisplayGameLEDs     ;If previously on, turn LEDs off
		LDI    R17, TRUE
		STS    DispOff, R17        ;mark display as currenty off
		RJMP   StoreBCount

BoardOn:

        LDI    ZL, LOW(GameBoard)
        LDI    ZH, HIGH(GameBoard)
        LD     R16, Z+ 
        LD     R17, Z              ;Load current game board to R17|R16
        RCALL  DisplayGameLEDs     ;Display the current game board
		LDI    R17, FALSE
		STS    DispOff, R17        ;mark display as currenty on
		RJMP   StoreBCount

StoreBCount:

        STS    BlinkCount, R18     ;Store counter back to memory

DoneBlinking:

        RET


; DisplayInterrupt
;
; Description:        This procedure is called by the event handler for the 
;                     timer0 interrupts generated each milisecond on the Hexer 
;                     system, and is used to display Hexer game data on the 2 
;                     game board displays.
;
; Operation:          On every clock interrupt, this routine is called, and
;                     based on a counter, determines which set of muxed LEDs in
;                     the display should be activated according to the muxing 
;                     frequency, then displays the data stored in the display
;                     buffer for those LEDs. Every LED is stored in the buffer 
;                     as either on or off, and at the mux frequency the set of 
;                     LEDs illuminated in the board are changed, rotating
;                     through all LEDs on the board. For each set of LEDs, ON or 
;                     OFF is sent out on port C, while the LEDs to illuminate are
;                     slected via mux select signals on port D.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   dispBuffer (R) - the data shown on the LED display
;                     CurMuxDigPat (R/W) - the counter keeping track of the mux 
;                                          selection to make
;                     CurMuxDig     - The digit currently selected to display                   
;
; Input:              None
; Ouput:              Outputs the display buffers and display select signals to 
;                     ports C and D
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: None
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

DisplayInterrupt:

    PUSH   R16               ;Used by BlinkDisplay
	PUSH   R17               ;Used in BlinkDisplay
    PUSH   R18               ;Save touched registers since this will be called 
    PUSH   R19               ; during event handling
    PUSH   ZL
    PUSH   ZH
    PUSH   R0


    LDI    R18, LEDSOFF    
    OUT    Dig_PORT, R18     ;Initialize LEDS to be turned off; set drivers low
                             ; to avoid showing wrong pattern on wrong LED line. 

	RCALL  BlinkDisplay      ;Set display for blinking before showing it

    CLR    R19               ;zero constant for calculations with adc
    LDS    R18, CurMuxDig    ;Get the current LED seg pattern to display 

MuxLED:                      ;Get and output digit pattern and select

    LDI    ZL, LOW(dispBuffer)  ;Get the current display buffer
    LDI    ZH, HIGH(dispBuffer)
    ADD    ZL, R18              ;Move up in the buffer to the selected digit 
    ADC    ZH, R19 

    LDS    R19, CurMuxDigPat ;Get the current drive pattern
    OUT    DIGIT_PORT, R19   ;And output it 

    LD     R0, Z             ;Get the digit pattern from the buffer
    OUT    DIG_PORT, R0      ;and output to the display 

    LSL    R19               ;Advance to the next digit drive pattern 
    INC    R18               ;And the next mux digit number 
    CPI    R18, DISP_LINES   ;Check if all digits have been displayed
    BRLO   UpdateDigCnt      ;If not, update count with new value 
    ;BRSH  ResetDigCnt       ;otherwise, reset digit count

ResetDigCnt:

    CLR    R18               ;On last segnent, reset to first 
    LDI    R19, INIT_PATT    ;Reset to first driver pattern as well 
    ;RJMP  UpdateDigCnt  

UpdateDigCnt:

    STS    CurMuxDig, R18    ;Store the new digit counter 
    STS    CurMuxDigPat, R19 ;And the new digit drive pattern 
    ;RJMP  EndInter          ;Done 

EndInter: 

    POP    R0
    POP    ZH
    POP    ZL
    POP    R19
    POP    R18               ;Restore touched registers since always called 
	POP    R17               ; during an interrupt
	POP    R16
    
    RET                      ;Done, so return


; ClearDisplay
;
; Description:        This procedure sets all LEDS in the game display to be off
;                     including both the game board display and the 7 segment 
;                     display.
;
; Operation:          Sets the data written to the board displays to all 0's, 
;                     so that on the next interrupt and until new data is 
;                     entered, the display will be blank (all LEDs off)
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   dispBuffer (W) - the data shown on the display
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, YL, YH, R17
; 
; Author:             Edward Speer
; Last Modified:      5/20/23

ClearDisplay:

    LDI    R16, DISP_LINES     ;Number of digits to be cleared 
    LDI    YL, LOW(dispBuffer) ;Load current buffer 
    LDI    YH, HIGH(dispBuffer)
    LDI    R17, LED_OFF        ;Load the pattern of an off LED 
    ;RJMP ClcBuffLoop          ;Go on to clear out buffer 

ClcBuffLoop:                   ;Loop through and clear each buffer index 
    
    ST    Y+, R17              ;Clear the digit
    DEC   R16                  ;Move to the next digit
    BRNE  ClcBuffLoop         ;If not done clearing digits, loop 
    ;BREQ EndClc               ;Otherwise, done clearing 

EndClc: 

    RET                        ;Done, so return


; DisplayHex
;
; Description:        This procedure sets the bytes in the display buffer which 
;                     represent the patterns shown on the 7 segment display 
;                     such that the 4 digits passed in as hex will be shown on 
;                     the 7 segment display (i.e 0x0A -> "A"). The passed in 
;                     hex is padded on the left by blanks.
;
; Operation:          Sets the data written to the board display to the patterns 
;                     indicated by the value passed in R16|R17, by performing 
;                     lookup of each digit in the segment table. Empty digits 
;                     are padded left using blanks.
;
; Arguments:          16 bit unsigned value to be shown on 7-segment in R16|R17
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   dispBuffer (W) - the data shown on the display
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R17, R16, R18, R20, YL, YH, R21, ZL, ZH
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

DisplayHex: 

    LDI    R18, SEG_NUM    ;Get the number of digits to display  
    CLR    R20             ;Zero for propogating carries 
    LDI    YL, LOW(dispBuffer+SEG_OFFS) ;Pointer to display buffer, offset to 
    LDI    YH, HIGH(dispBuffer+SEG_OFFS); 7 segment display patterns
    ;RJMP  DisplayLoop     ;Go on to display digits 

DisplayLoop:               ;Loop through and set each digit 

    MOV    R21, R16        ;Get the digit to display 
    ANDI   R21, LOW_NIBBLE ;Digit is in the low nibble 
    LDI    ZL, LOW(DigitSegTable << 1)  ;Point to start of seg table
    LDI    ZH, HIGH(DigitSegTable << 1) ;Shifted for byte addressing
    ADD    ZL, R21         ;Get offset in Segment Table 
    ADC    ZH, R20 
    LPM                    ;Lookup the digit pattern; store in R0

DisplayDigits:

    ST     Y+, R0          ;Store the looked up digit in the next buffer index 

EndLoop:

    LSR    R17             ;move the next digit into place
    ROR    R16			   ;each digit is 4 bits
    LSR    R17
    ROR    R16
    LSR    R17
    ROR    R16
    LSR    R17
    ROR    R16

    DEC    R18             ;Update digit counter to next digit
    BRNE   DisplayLoop     ;If not all digits have been displayed, then loop 
    ;BRE   EndDisp         ;Otherwise, done updating buffer 

EndDisp:

    RET                    ;Done, so return


; DisplayGameLEDs
;
; Description:        This procedure takes in a 16 bit mask and triggers the 
;                     15 LED display to show the sequence indicated by the mask.
;
; Operation:          Writes the mask input into the function to the BoardBuffer 
;                     shared variable, masking out bit 12, so that it will be 
;                     displayed by the display muxing event handler.
;
; Arguments:          16 bit mask to be displayed on the 15 LED display in 
;                     R16|R17 giving the game LEDS as the following sequence:
;                      9, 1, 5, None, 10, 4, 3, 2, 13, 11, 8, 15, 14, 12, 7, 6
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   BoardBuffer (W) - the game data to be shown on the game
;                                       board display (Game LEDS stored at the 
;                                                      beginning of buffer)
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: YL, YH, R17, R16
; 
; Author:             Edward Speer
; Last Modified:      5/20/23

DisplayGameLEDs:

    LDI    YL, LOW(dispBuffer)  ;Pointer to buffer to store sequences in
    LDI    YH, HIGH(dispBuffer)
    ANDI   R17, HIGH_MASK       ;Mask out bit 12 from high bytes of argument 
    ST     Y+, R17              ;Store new pattern for high bytes of game LEDS 
    ANDI   R16, LOW_MASK        ;Mask low bytes of game LEDS from argument
    ST     Y+, R16              ;Store new pattern for low bytes of game LEDS

    RET                        ;Done, so return


.dseg 

dispBuffer:    .BYTE    DISP_LINES     ;Buffer holding display patterns

;Buffer Layout:
;  BYTE1: LEDS 9, 1, 5, None, 10, 4, 3, 2
;  BYTE2: LEDS 13, 11, 8, 15, 14, 12, 7, 6
;  BYTE3: 7 Seg Digit 4
;  BYTE4: 7 Seg Digit 3
;  BYTE5: 7 Seg Digit 2
;  BYTE6: 7 Seg Digit 1
;  BYTE4: 7 Seg Other Features

CurMuxDig:     .BYTE    1              ;Current display display data to out
CurMuxDigPat:  .BYTE    1              ;Current display output select pattern

IsBlinking:    .BYTE    1              ;Flag indicating if display is blinking
BlinkCount:    .BYTE    1              ;Counter used to blink the display
DispOff:       .BYTE    1              ;Used in blinking for state of board

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                   DISP.INC                                 ;
;                             Display Definitions                            ;
;                       Microprocessor-Based Hexer Game                      ;
;                                 Include File                               ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the display hardware and constants definitions for the
; Microprocessor-Based Hexer game.
;
; Revision History:
;     5/19/23   Edward Speer    initial revision
;     5/20/23   Edward Speer    Add port constants and specific digit patterns
;     5/20/23   Edward Speer    Debug display muxing
;     6/15/23   Edward Speer    Rename constants 
;     6/15/23   Edward Speer    Add blinking constants

;IO constants 

.EQU     LEDSOFF     = 0x00                ;Port D value to turn off all LEDS 
.EQU     LED_OFF     = 0b00000000          ;Constant pattern for an off LED

;Display parameters

.EQU     LOW_NIBBLE  = 0b00001111          ;Mask for the low nibble of a byte 
.EQU     DISP_LINES  = 7                   ;Number of multiplexed display lines
.EQU     SEG_OFFS    = 3                   ;Offset to reach segment display in buffer
.EQU     SEG_NUM     = 4                   ;The number of segment display digits

.EQU     INIT_PATT   = 0b00000001          ;Initial segment drive pattern 
.EQU     HIGH_MASK   = 0b11101111          ;Mask for high bits of game LEDS
.EQU     LOW_MASK    = 0b11111111          ;Mask for low bits of game LEDS

.EQU     BLINKING    = 1                   ;Value of blinking flag when blinking
.EQU     NBLINKING   = 0                   ;Value of blinking flag when not blinking
.EQU     BL_TIME     = 200                 ;Frequency with which to blink display
.EQU     FALSE       = 0                   ;Flag value when false
.EQU     TRUE        = 1                   ;Flag value when true

;Ports 

.EQU    DIG_PORT       = PORTC             ;LED display patterns on port C 
.EQU    DIGIT_PORT     = PORTD             ;LED mux selection on port D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                HARDWARE_INIT                               ;
;                      Hardware Initialization Functions                     ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the hardware initialization function for the I/O port 
; and timer used in switch debouncing for the Microprocessor-Based Hexer Game.
;
; Public Routines: InitSwitchIO - Intializes Port D for switch input 
;                  LEDBoardInit - Initializes ports C and D for LED muxing 
;                  InitMsTimer  - Initializes timer0 to provide 1 ms timer 
;                                 interrupts to the system
;                  SpeakerIoInit- Intializes portB to ouput to speaker
;
; Revision History:
;     5/4/23    Edward Speer    Initial revision 
;     5/4/23    Edward Speer    Comments updated
;     5/19/23   Edward Speer    Add IO setup for display code
;     5/20/23   Edward Speer    Update comments
;     6/3/23    Edward Speer    Add speaker initialization 
;     6/3/23    Edward Speer    Debug speaker control settings 
;     6/15/23   Edward Speer    Finalize comments

.cseg 


; InitSwitchIO 
;
; Description:        This procedure initializes the IO Port used to read 
;                     the value of the switches
; Operation:          The IO mode for PortE is initialized to input mode  
;                     by writing to the port direction register
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Varibales:   None
;
; Input:              None
; Ouput:              Output switch direction to switch direction register
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16
; 
; Author:             Edward Speer
; Last Modified:      6/14/23

InitSwitchIo:

        LDI    R16, READ 
        OUT    DDRE, R16     ;Instruct PortE to be used as an input

        RET                  ;Done, so return


; LEDBoardInit
;
; Description:        This procedure initializes the I/O ports needed to display 
;                     data on the 7 segment display and the 15 LED display in 
;                     the Hexer game. Also initializes all LED's to off
;
; Operation:          Sets ports C and D as outputs by setting the port 
;                     direction registers, then turns off LEDs by setting port D 
;                     to the state of all LED's off
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   None
;
; Input:              None
; Ouput:              Outputs port directions to the port direction registers 
;                     for port C and port D
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16
; 
; Author:             Edward Speer
; Last Modified:      6/14/23

LEDBoardInit:
        
        LDI    R16, OUTP
        OUT    DDRC, R16     ;Set direction register for port C to output
        OUT    DDRD, R16     ;Set direction register for port D to output

        LDI    R16, LEDSOFF  ;Turn off LEDS by disabling voltage across all LEDS
        OUT    DIGIT_PORT, R16

        RET                  ;Done, so return


; InitMsTimer
;
; Description:        This procedure initializes timer 2 to provide a 1 ms timer 
;                     for the system, generating interrupts each milisecond 
; Operation:          The timer mode for 8 bit timer is initialized, prescaled   
;                     to CLK/32, and the timer interrupts setup for generating 
;                     1 ms interrupts
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Varibales:   None
;
; Input:              None
; Ouput:              Timer settings output to timer control register
;                     TIMSK register edited to allow timer interrupts Output 
;                     Compare register set for 1 ms timer
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16
; 
; Author:             Edward Speer
; Last Modified:      6/15/23

InitMsTimer:

        LDI    R16, TIMERCLK32
        OUT    TCCR0, R16       ;Set timer controls

SetOutputComp:

        LDI    R16, OUTC 
        OUT    OCR0, R16       ;Set output control register

EnableTimerInt:

        LDI    R16, TIMSKEN
        IN     R17, TIMSK 
        OR     R16, R17         ;Change only the timer0 interrupt bit in TIMSK
        OUT    TIMSK, R16       ;Enable timer interrupts

        RET                     ;Done, so return


; SpeakerIOInit
;
; Description:        This procedure initializes the I/O ports needed to produce
;                     tones on the speaker.
;
; Operation:          Sets the data direction register for the speaker port 
;                     (Port OC1A)
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   None
;
; Input:              None
; Ouput:              Outputs port direction to OC1A 
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: None
; 
; Author:             Edward Speer
; Last Modified:      6/3/23

SpeakerIOInit:

      LDI    R16, OUTP
      OUT    DDRB, R16    ;Set data direction register for speaker to output

      RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                  MOVES.ASM                                 ;
;                              User Move Functions                           ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the functions necessary to change game data based on the 
; user input of a game move via the switches on the hexer board. This consists 
; mainly of the functions needed to shift, invert, or swap the LEDs in the game 
; board.
;
; Public Routines: MoveWhite - Performs the move corresponding to a white switch
;                  MoveBlack - Performs the move corresponding to a black switch 
;                  MoveBlue  - Performs the move corresponding to a blue switch 
;                  MoveGreen - Performs the move corresponding to a green switch
;                  MoveRed   - Performs the move corresponding to a red switch 
;                  MoveReset0 - Shifts a 0 into the LEDs as a shift register 
;                  MoveReset1 - Shifts a 1 intot he LEDs as a shift register
; Private Routines: SetBitEq - Sets one bit equal to another bit from 16 bits
;                   SetBit   - Sets a bit equal to a passed constant in 16 bits
;                   GetBit   - Gets the value of a certain bit from 15 bits
;
; Revision History:
;     6/12/23   Edward Speer    Initial Revision
;     6/13/23   Edward Speer    Fix GameBoard addressing issue
;     6/13/23   Edward Speer    Add manual reset 0 and 1 shifts
;     6/15/23   Edward Speer    Fix label problem with SetBit
;     6/16/23   Edward Speer    Update comments 

.cseg

; MoveWhite
;
; Description:        This procedure inverts the LEDS in the white inner hexagon 
;                     on the game board.
;
; Operation:          XOR's the LEDs of the white inner game board with 1's 
;                     to invert their values.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R18, R19, YL, YH
; :        0 bytes
; 
; Author:             Edward Speer
; Last Modified:      6/12/23

MoveWhite:

        LDI    R16, WHITE_ON_LOW
        LDI    R17, WHITE_ON_HIGH          ;Get the mask for the white hexagon in LEDs

        LDI    YL, LOW(GameBoard)
        LDI    YH, HIGH(GameBoard)         ;Get the data address to the GameBoard 

        LD     R18, Y+
        LD     R19, Y                      ;Get the current Gameboard 

        EOR    R16, R18 
        EOR    R17, R19                    ;Invert the bits in the white hexagon

        ST     Y, R17
        ST     -Y, R16                     ;Store back the inverted Game Board 

        RET                                ;And done so return


; MoveBlue
;
; Description:        This procedure rotates the LEDs in the blue hexagon in the 
;                     game board clockwise 
;
; Operation:          Swaps the positions of the bits in the black hexagon until 
;                     all LEDs have been rotated one position clockwise
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R25
;
; Author:             Edward Speer
; Last Modified:      6/12/23

MoveBlue:
    
        LDI    R16, LED_5 
        RCALL  GetI           ;Get the state of LED_5 in R25
		PUSH   R25            ;And save it 

        LDI    R16, LED_5 
        LDI    R17, LED_4
        RCALL  SetBitEq       ;LED5 = LED4

        LDI    R16, LED_4 
        LDI    R17, LED_8
        RCALL  SetBitEq       ;LED4 = LED8

        LDI    R16, LED_8 
        LDI    R17, LED_13
        RCALL  SetBitEq       ;LED8 = LED13

        LDI    R16, LED_13 
        LDI    R17, LED_14
        RCALL  SetBitEq       ;LED13 = LED14 

        LDI    R16, LED_14 
        LDI    R17, LED_10
        RCALL  SetBitEq       ;LED14 = LED10 

        POP    R25            ;Restore the saved LED in R25
        LDI    R16, LED_10
        RCALL  SetBit         ;LED10 = R25 (Stored former value of LED5)

        RET                   ;And done



; MoveBlack
;
; Description:        This procedure rotates the LEDs in the black hexagon in the 
;                     game board counter-clockwise
;
; Operation:          Swaps the positions of the bits in the blue hexagon until 
;                     all LEDs have been rotated one position counter-clockwise
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R25
;
; Author:             Edward Speer
; Last Modified:      6/12/23

MoveBlack:

        LDI    R16, LED_2 
        RCALL  GetI           ;Get the state of LED_2 in R25
		PUSH   R25            ;and save it

        LDI    R16, LED_2 
        LDI    R17, LED_3
        RCALL  SetBitEq       ;LED2 = LED3 

        LDI    R16, LED_3 
        LDI    R17, LED_8
        RCALL  SetBitEq       ;LED3 = LED8 

        LDI    R16, LED_8 
        LDI    R17, LED_12
        RCALL  SetBitEq       ;LED8 = LED12

        LDI    R16, LED_12 
        LDI    R17, LED_11
        RCALL  SetBitEq       ;LED12 = LED11 

        LDI    R16, LED_11 
        LDI    R17, LED_6
        RCALL  SetBitEq       ;LED11 = LED6 

        POP    R25            ;Restore saved LED in R25
        LDI    R16, LED_6
        RCALL  SetBit         ;LED6 = R25 (Stored former value of LED2)

        RET                   ;And done


; MoveRed
;
; Description:        This procedure rotates the LEDs in the red triangle in the 
;                     game board clockwise
;
; Operation:          Swaps the positions of the bits in the red triangle until 
;                     all LEDs have been rotated one position clockwise
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R25 
;
; Author:             Edward Speer
; Last Modified:      6/12/23

MoveRed:

        LDI    R16, LED_1 
        RCALL  GetI           ;Get the state of LED_1 in R25
		PUSH   R25            ;And save it

        LDI    R16, LED_1 
        LDI    R17, LED_3
        RCALL  SetBitEq       ;LED1 = LED3 

        LDI    R16, LED_3 
        LDI    R17, LED_7
        RCALL  SetBitEq       ;LED3 = LED7 

        LDI    R16, LED_7 
        LDI    R17, LED_11
        RCALL  SetBitEq       ;LED7 = LED11 

        LDI    R16, LED_11 
        LDI    R17, LED_12
        RCALL  SetBitEq       ;LED11 = LED12 

        LDI    R16, LED_12 
        LDI    R17, LED_13
        RCALL  SetBitEq       ;LED12 = LED13 

        LDI    R16, LED_13 
        LDI    R17, LED_14
        RCALL  SetBitEq       ;LED13 = LED14 

        LDI    R16, LED_14 
        LDI    R17, LED_9
        RCALL  SetBitEq       ;LED14 = LED9 

        LDI    R16, LED_9 
        LDI    R17, LED_4
        RCALL  SetBitEq       ;LED9 = LED4 

        POP    R25            ;Restore the saved LED in R25
		LDI    R16, LED_4
        RCALL  SetBit         ;LED4 = R25 (Stored former value of LED1)

        RET                   ;And done


; MoveGreen
;
; Description:        This procedure rotates the LEDs in the green triangle in the 
;                     game board counter-clockwise
;
; Operation:          Swaps the positions of the bits in the green triangle until 
;                     all LEDs have been rotated one position counter-clockwise
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R25 
;
; Author:             Edward Speer
; Last Modified:      6/12/23

MoveGreen:

        LDI    R16, LED_15 
        RCALL  GetI           ;Get the state of LED_15 in R25
		PUSH   R25            ;And save it

        LDI    R16, LED_15 
        LDI    R17, LED_12
        RCALL  SetBitEq       ;LED15 = LED12 

        LDI    R16, LED_12 
        LDI    R17, LED_7
        RCALL  SetBitEq       ;LED12 = LED7 

        LDI    R16, LED_7 
        LDI    R17, LED_2
        RCALL  SetBitEq       ;LED7 = LED2 

        LDI    R16, LED_2 
        LDI    R17, LED_3
        RCALL  SetBitEq       ;LED2 = LED3 

        LDI    R16, LED_3 
        LDI    R17, LED_4
        RCALL  SetBitEq       ;LED3 = LED4 

        LDI    R16, LED_4 
        LDI    R17, LED_5
        RCALL  SetBitEq       ;LED4 = LED5 

        LDI    R16, LED_5 
        LDI    R17, LED_9
        RCALL  SetBitEq       ;LED5 = LED9 

        LDI    R16, LED_9 
        LDI    R17, LED_13
        RCALL  SetBitEq       ;LED9 = LED13 

        POP    R25            ;Restore the saved LED in R25
        LDI    R16, LED_13
        RCALL  SetBit         ;LED13 = R25 (Stored former value of LED15)

        RET                   ;And done


; MoveReset1
;
; Description:        This procedure rotates a 1 into the GameBoard at position 
;                     1 and shifts all other LEDs in the board accordingly
;
; Operation:          Swaps the positions of the bits in the gameboard clearing
;                     LED 1, and shifts a 1 into position 1
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R25 
;
; Author:             Edward Speer
; Last Modified:      6/12/23

MoveReset1:

        LDI    R16, LED_15
        LDI    R17, LED_14 
        RCALL  SetBitEq         ;LED15 = LED14

        LDI    R16, LED_14
        LDI    R17, LED_13 
        RCALL  SetBitEq         ;LED14 = LED13 

        LDI    R16, LED_13
        LDI    R17, LED_12 
        RCALL  SetBitEq         ;LED13 = LED_12

        LDI    R16, LED_12
        LDI    R17, LED_11 
        RCALL  SetBitEq         ;LED12 = LED11

        LDI    R16, LED_11
        LDI    R17, LED_10 
        RCALL  SetBitEq         ;LED11 = LED10

        LDI    R16, LED_10
        LDI    R17, LED_9 
        RCALL  SetBitEq         ;LED10 = LED9

        LDI    R16, LED_9
        LDI    R17, LED_8 
        RCALL  SetBitEq         ;LED9 = LED8

        LDI    R16, LED_8
        LDI    R17, LED_7 
        RCALL  SetBitEq         ;LED8 = LED_7

        LDI    R16, LED_7
        LDI    R17, LED_6 
        RCALL  SetBitEq         ;LED7 = LED6

        LDI    R16, LED_6
        LDI    R17, LED_5 
        RCALL  SetBitEq         ;LED6 = LED5

        LDI    R16, LED_5
        LDI    R17, LED_4 
        RCALL  SetBitEq         ;LED5 = LED4

        LDI    R16, LED_4
        LDI    R17, LED_3 
        RCALL  SetBitEq         ;LED4 = LED3 

        LDI    R16, LED_3
        LDI    R17, LED_2 
        RCALL  SetBitEq         ;LED3 = LED2 

        LDI    R16, LED_2
        LDI    R17, LED_1 
        RCALL  SetBitEq         ;LED2 = LED1

        LDI    R16, LED_1 
        LDI    R25, LEDOn 
        RCALL  SetBit           ;LED1 = 1

		RET


; MoveReset0
;
; Description:        This procedure rotates a 0 into the GameBoard at position 
;                     1 and shifts all other LEDs in the board 1 positon
;
; Operation:          Swaps the positions of the bits in the gameboard clearing
;                     LED 1, and shifts a 0 into position 1
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R25 
;
; Author:             Edward Speer
; Last Modified:      6/12/23

MoveReset0:

        LDI    R16, LED_15
        LDI    R17, LED_14 
        RCALL  SetBitEq         ;LED15 = LED14

        LDI    R16, LED_14
        LDI    R17, LED_13 
        RCALL  SetBitEq         ;LED14 = LED13 

        LDI    R16, LED_13
        LDI    R17, LED_12 
        RCALL  SetBitEq         ;LED13 = LED_12

        LDI    R16, LED_12
        LDI    R17, LED_11 
        RCALL  SetBitEq         ;LED12 = LED11

        LDI    R16, LED_11
        LDI    R17, LED_10 
        RCALL  SetBitEq         ;LED11 = LED10

        LDI    R16, LED_10
        LDI    R17, LED_9 
        RCALL  SetBitEq         ;LED10 = LED9

        LDI    R16, LED_9
        LDI    R17, LED_8 
        RCALL  SetBitEq         ;LED9 = LED8

        LDI    R16, LED_8
        LDI    R17, LED_7 
        RCALL  SetBitEq         ;LED8 = LED_7

        LDI    R16, LED_7
        LDI    R17, LED_6 
        RCALL  SetBitEq         ;LED7 = LED6

        LDI    R16, LED_6
        LDI    R17, LED_5 
        RCALL  SetBitEq         ;LED6 = LED5

        LDI    R16, LED_5
        LDI    R17, LED_4 
        RCALL  SetBitEq         ;LED5 = LED4

        LDI    R16, LED_4
        LDI    R17, LED_3 
        RCALL  SetBitEq         ;LED4 = LED3 

        LDI    R16, LED_3
        LDI    R17, LED_2 
        RCALL  SetBitEq         ;LED3 = LED2 

        LDI    R16, LED_2
        LDI    R17, LED_1 
        RCALL  SetBitEq         ;LED2 = LED1

        LDI    R16, LED_1 
        LDI    R25, LEDOff 
        RCALL  SetBit           ;LED1 = 0

		RET



; SetBitEq
;
; Description:        This procedure sets bit i = bit j in the gameboard, i.e 
;                     GameBoard[i] = GameBoard[j]
;
; Operation:          To set bit i = bit j, mask out all bits other than bit j,
;                     rotate bit j until it is in the position of bit j, then in 
;                     the GameBoard, mask out bit j and OR it with the bit j 
;                     shifted into position. Then store this back to the GameBoard.
;
; Arguments:          i passed into R16, J passed into R17
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  YL, YH, R24, R25, R23, R17, R18, R19, R16 R20
; 
; Author:             Edward Speer
; Last Modified:      6/16/23

SetBitEq:

        LDI    YL, LOW(GameBoard)
        LDI    YH, HIGH(GameBoard) ;Get the data address to the GameBoard 

        LD     R18, Y+ 
        LD     R19, Y                  ;Get the current Gameboard

CreateMaskj:

        LDI    R24, Bit0Mask_LOW
        LDI    R25, Bit0Mask_HIGH     ;Load in a mask of bit 0
        CLR    R23
        OR     R23, R17               ;Copy j into R13 and set zero flag

UntilJ:                               ;Shift mask until masking bit j 

        BREQ   ShiftToI               ;If masking bit j, then move onto shifting
        ;BRNE  RotateMaskJ            ;Otherwise, continue shifting mask

RotateMaskJ:

        LSL    R24
        ROL    R25                    ;Shift masked bit to the left 
        DEC    R23                    ;Reduce shift counter
        RJMP   UntilJ                 ;Repeat shifting loop

ShiftToI:

        AND    R24, R18
        AND    R25, R19               ;Mask out all bits except j from GameBoard copy 
        CP     R17, R16
        BRLT   ShiftLeftJ             ;if j < i, need to shift bit j left
        ;BRGE  ShiftRightJ            ;Otherwise, need to shift bit j right 

ShiftRightJ:

        CP     R17, R16 
        BREQ   CreateMaski             ;If bit j shifted to position i, done
        ;BRNE  ShiftRightJ             ;Otherwise continue shifting
        LSR    R25
        ROR    R24                     ;Shift bit j to the right
        DEC    R17                     ;j = j - 1 
        RJMP   ShiftRightJ             ;Repeat shifting loop 

ShiftLeftJ:

        LSL    R24
        ROL    R25                     ;Shift bit j to the left 
        INC    R17                     ;j = j+1
        CP     R17, R16
        BRNE   ShiftLeftJ              ;If j != i, shift left again 
        ;BREQ  CreateMaski             ;If j=i, done shifting


CreateMaski:

        LDI   R20, MaskOut0_LOW
        LDI   R21, MaskOut0_HIGH      ;Load a mask to remove bit 0 
        CLR   R22
        OR    R22, R16                 ;Load in i and set 0 flag

UntilI:

        BREQ  SetI                     ;If shifted to i, done shifting 
        ;BRNE RotateMaskI              ;Otherwise continue shifting

RotateMaskI:

        SEC                           ;Always shift in a 1 to the mask
        ROL    R20
        ROL    R21                    ;Shift masked bit to the left 
        DEC    R22                    ;Reduce shift counter
        RJMP   UntilI                 ;Repeat shifting loop

SetI:

        AND    R20, R18
        AND    R21, R19               ;Mask out bit i from GameBoard 
        OR     R20, R24 
        OR     R21, R25               ;Bit i = bit j in R21|R20

StoreBoard: 

        ST     Y, R21 
        ST     -Y, R20                 ;Store transformed board to GameBoard 
  
        RET                           ;And done


;SetBit 
;
; Description:        This procedure sets bit i = c in the gameboard, i.e 
;                     GameBoard[i] = c
;
; Operation:          To set bit i = c, mask out bit i from the gameBoard,
;                     create a mask with c in position i, and then OR the board 
;                     with the mask.
;
; Arguments:          i passed into R16, c (0 or 1) passed into R25 
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: None
; 
; Author:             Edward Speer
; Last Modified:      6/12/23

Setbit:

        LDI    YL, LOW(GameBoard)
        LDI    YH, HIGH(GameBoard)    ;Get the data address to the GameBoard 

        LD     R18, Y+ 
        LD     R19, Y                 ;Get the current Gameboard 

CreateCMask:
        
        MOV    R14, R25               ;Extend c to 16 bits in R14|R15
        CLR    R15                    ;Load high byte of a mask of bit 0
        CLR    R13
        OR     R13, R16               ;Get i as loop counter and set zero flag 

ShiftCLoop:

        BREQ  IFromBoard              ;if loop counter 0, done shifting
        ;BRNE ShiftC                  ;otherwise continue shifting c 

ShiftC:

        LSL    R14
        ROL    R15                    ;Shift c to the left in the mask 
        DEC    R13                    ;loopCounter -= 1
        RJMP   ShiftCLoop             ;repeat loop 

IFromBoard:

        LDI   R20, MaskOut0_LOW
        LDI   R21, MaskOut0_HIGH       ;Load a mask to remove bit 0 
        CLR   R22
        OR    R22, R16                 ;Load in i and set 0 flag

IMaskLoop:

        BREQ  SetIToC                  ;If shifted to i, done shifting 
        ;BRNE RotToI                   ;Otherwise continue shifting

RotToI:

        SEC                           ;Always shift in a 1 to the mask
        ROL    R20
        ROL    R21                    ;Shift masked bit to the left 
        DEC    R22                    ;Reduce shift counter
        RJMP   IMaskLoop              ;Repeat shifting loop

SetIToC:

        AND    R20, R18
        AND    R21, R19               ;Mask out bit i from GameBoard
        OR     R20, R14 
        OR     R21, R15               ;Set i = c in R21|R20

        ST     Y, R21 
        ST     -Y, R20                ;Store transformed board to GameBoard 

        RET                           ;And done


;GetI 
;
; Description:        This procedure returns the value of the bit i in the game 
;                     board, either 0 or 1
;
; Operation:          Rotate bit i into position 0, then set the preceeding 7
;                     bits to 0 and return 8 bits 
;
; Arguments:          i passed into R16
; Return Value:       value at bit i returned in R25 
;
; Local Variables:    None
; Shared Variables:   GameBoard - the current GameBoard given as the status of 
;                     the 16 game LEDs, with 1's indicating LED on, and 0's 
;                     indicating LEDs off. 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: YL, YH, R18, R19, R16, R25
; 
; Author:             Edward Speer
; Last Modified:      6/12/23

GetI:
        
        LDI    YL, LOW(GameBoard)
        LDI    YH, HIGH(GameBoard) ;Get the data address to the GameBoard 

        LD     R18, Y+ 
		LD     R19, Y                  ;Get the current Gameboard
		AND    R16, R16                ;Set 0 flag if i=0
        
IShiftLoop:

        BREQ   Mask7Bits               ;if bit i in position 0, mask other bits 
        ;BRNE  IShift                  ;Otherwise continue shifting

IShift:

        LSR    R19 
        ROR    R18                     ;Shift R19|R18 to the right 
        DEC    R16                     ;Reduce needed shift counter
        RJMP   IShiftLoop              ;Repeat shifting loop

Mask7Bits:

        LDI    R25, Bit0Mask_LOW
        AND    R25, R18                ;Mask out the 7 bits preceeding bit i
        
        RET                            ;Return 0b0000000(i) in R25

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                  MOVES.INC                                 ;
;                             User Move Definitions                          ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains all the constants needed to allow the user to make moves 
; which manipulate the game data.
;
; Revision History:
;     6/12/23    Edward Speer    initial revision
;     6/15/23    Edward Speer    Seperate low and high bytes for ease of use 
;     6/16/23    Edward Speer    Update comments

;Game board constants 


.EQU    WHITE_ON_LOW  = 0b10000110       ;Bytes giving LEDs of white hexagon
.EQU    WHITE_ON_HIGH = 0b10000110       ;Bytes giving LEDs of white hexagon
.EQU    LED_1    = 14                    ;bit of GameBoard storing LED1 
.EQU    LED_2    = 8                     ;bit of GameBoard storing LED2 
.EQU    LED_3    = 9                     ;bit of GameBoard storing LED3  
.EQU    LED_4    = 10                    ;bit of GameBoard storing LED4  
.EQU    LED_5    = 13                    ;bit of GameBoard storing LED5  
.EQU    LED_6    = 0                     ;bit of GameBoard storing LED6  
.EQU    LED_7    = 1                     ;bit of GameBoard storing LED7  
.EQU    LED_8    = 5                     ;bit of GameBoard storing LED8  
.EQU    LED_9    = 15                    ;bit of GameBoard storing LED9 
.EQU    LED_10   = 11                    ;bit of GameBoard storing LED10  
.EQU    LED_11   = 6                     ;bit of GameBoard storing LED11  
.EQU    LED_12   = 2                     ;bit of GameBoard storing LED12 
.EQU    LED_13   = 7                     ;bit of GameBoard storing LED13 
.EQU    LED_14   = 3                     ;bit of GameBoard storing LED14 
.EQU    LED_15   = 4                     ;bit of GameBoard storing LED15 


.EQU    Bit0Mask_LOW  = 0000000001       ;Mask giving bit 0 of a 16 bit variable
.EQU    Bit0Mask_HIGH = 0b00000000       ;Mask giving bit 0 of a 16 bit variable
.EQU    MaskOut0_LOW  = 0b11111110       ;Mask removing bit 0 of 16 bit variable
.EQU    MaskOut0_HIGH = 0b11111111       ;Mask removing bit 0 of 16 bit variable

.EQU   LEDOn    = 0b00000001             ;Constant 1 turning on an LED
.EQU   LEDOff   = 0b00000000             ;Constant 0 turning an LED off 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                   SEGTABLE                                 ;
;                           Tables of 7-Segment Codes                        ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains tables of 7-segment codes.  The segment ordering is
; given below.  The tables included are:
;    ASCIISegTable - table of codes for 7-bit ASCII characters
;    DigitSegTable - table of codes for hexadecimal digits
;
; Revision History:
;     5/18/23  auto-generated           initial revision
;     5/18/23  Glen George              added DigitSegTable



; local include files
;    none




;table is in the code segment
        .cseg




; ASCIISegTable
;
; Description:      This is the segment pattern table for ASCII characters.
;                   It contains the active-high segment patterns for all
;                   possible 7-bit ASCII codes.  Codes which do not have a
;                   "reasonable" way of being displayed on a 7-segment display
;                   are left blank.  None of the codes set the decimal point.
;
; Notes:            READ ONLY tables should always be in the code segment so
;                   that in a standalone system it will be located in the
;                   ROM with the code.
;
; Author:           auto-generated
; Last Modified:    May 18, 2023

ASCIISegTable:


;        DB       fbeagedc    fbeagedc   ; ASCII character

        .DB     0b00000000, 0b00000000   ; NUL, SOH
        .DB     0b00000000, 0b00000000   ; STX, ETX
        .DB     0b00000000, 0b00000000   ; EOT, ENQ
        .DB     0b00000000, 0b00000000   ; ACK, BEL
        .DB     0b00000000, 0b00000000   ; backspace, TAB
        .DB     0b00000000, 0b00000000   ; new line, vertical tab
        .DB     0b00000000, 0b00000000   ; form feed, carriage return
        .DB     0b00000000, 0b00000000   ; SO, SI
        .DB     0b00000000, 0b00000000   ; DLE, DC1
        .DB     0b00000000, 0b00000000   ; DC2, DC3
        .DB     0b00000000, 0b00000000   ; DC4, NAK
        .DB     0b00000000, 0b00000000   ; SYN, ETB
        .DB     0b00000000, 0b00000000   ; CAN, EM
        .DB     0b00000000, 0b00000000   ; SUB, escape
        .DB     0b00000000, 0b00000000   ; FS, GS
        .DB     0b00000000, 0b00000000   ; AS, US

;        DB       fbeagedc    fbeagedc   ; ASCII character

        .DB     0b00000000, 0b00000000   ; space, !
        .DB     0b11000000, 0b00000000   ; ", #
        .DB     0b00000000, 0b00000000   ; $, %
        .DB     0b00000000, 0b01000000   ; &, '
        .DB     0b10110110, 0b01010011   ; (, )
        .DB     0b00000000, 0b00000000   ; *, +
        .DB     0b00000000, 0b00001000   ; ,, -
        .DB     0b00000000, 0b00000000   ; ., /
        .DB     0b11110111, 0b01000001   ; 0, 1
        .DB     0b01111110, 0b01011011   ; 2, 3
        .DB     0b11001001, 0b10011011   ; 4, 5
        .DB     0b10111111, 0b01010001   ; 6, 7
        .DB     0b11111111, 0b11011001   ; 8, 9
        .DB     0b00000000, 0b00000000   ; :, ;
        .DB     0b00000000, 0b00001010   ; <, =
        .DB     0b00000000, 0b00000000   ; >, ?

;        DB       fbeagedc    fbeagedc   ; ASCII character

        .DB     0b01111111, 0b11111101   ; @, A
        .DB     0b11111111, 0b10110110   ; B, C
        .DB     0b11110111, 0b10111110   ; D, E
        .DB     0b10111100, 0b10111111   ; F, G
        .DB     0b11101101, 0b01000001   ; H, I
        .DB     0b01100111, 0b00000000   ; J, K
        .DB     0b10100110, 0b00000000   ; L, M
        .DB     0b00000000, 0b11110111   ; N, O
        .DB     0b11111100, 0b00000000   ; P, Q
        .DB     0b00000000, 0b10011011   ; R, S
        .DB     0b00000000, 0b11100111   ; T, U
        .DB     0b00000000, 0b00000000   ; V, W
        .DB     0b00000000, 0b11001001   ; X, Y
        .DB     0b00000000, 0b10110110   ; Z, [
        .DB     0b00000000, 0b01010011   ; \, ]
        .DB     0b00000000, 0b00000010   ; ^, _

;        DB       fbeagedc    fbeagedc   ; ASCII character

        .DB     0b10000000, 0b00000000   ; `, a
        .DB     0b10101111, 0b00101110   ; b, c
        .DB     0b01101111, 0b00000000   ; d, e
        .DB     0b00000000, 0b11011011   ; f, g
        .DB     0b10101101, 0b00000001   ; h, i
        .DB     0b00000000, 0b00000000   ; j, k
        .DB     0b10100100, 0b00000000   ; l, m
        .DB     0b00101101, 0b00101111   ; n, o
        .DB     0b00000000, 0b00000000   ; p, q
        .DB     0b00101100, 0b00000000   ; r, s
        .DB     0b10101110, 0b00100111   ; t, u
        .DB     0b00000000, 0b00000000   ; v, w
        .DB     0b00000000, 0b11001011   ; x, y
        .DB     0b00000000, 0b00000000   ; z, {
        .DB     0b01000001, 0b00000000   ; |, }
        .DB     0b00010000, 0b00000000   ; ~, rubout




; DigitSegTable
;
; Description:      This is the segment pattern table for hexadecimal digits.
;                   It contains the active-high segment patterns for all hex
;                   digits (0123456789AbCdEF).  None of the codes set the
;                   decimal point.  
;
; Notes:            READ ONLY tables should always be in the code segment so
;                   that in a standalone system it will be located in the
;                   ROM with the code.
;
; Author:           Glen George
; Last Modified:    May 18, 2023

DigitSegTable:


;        DB       eaecgfdb    eaecgfdb   ; Hex Digit

        .DB     0b11110111, 0b01000001   ; 0, 1
        .DB     0b01111110, 0b01011011   ; 2, 3
        .DB     0b11001001, 0b10011011   ; 4, 5
        .DB     0b10111111, 0b01010001   ; 6, 7
        .DB     0b11111111, 0b11011001   ; 8, 9
        .DB     0b11111101, 0b10101111   ; A, b
        .DB     0b10110110, 0b01101111   ; C, d
        .DB     0b10111110, 0b10111100   ; E, F

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                 SOUND.ASM                                  ;
;                              Sound Functions                               ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the routines which play the game sound effects for the Hexer 
; game. Sounds are played by sending the correct frequencies to the speaker 
; on the board via the PlayNote routine in speaker.asm.
;
; Public Routines: InitSoundVars - Initializes the variables needed to play music 
;                  SoundInterrupt- Uses a counter during each interrupt to change
;                                  notes every 8th note interval
;                  PlayStartupSound - Causes the board to play the game music
;                  PlayWinSound  - Causes the  board to play the win music 
;
; Revision History:
;     6/13/23   Edward Speer    Initial Revision
;     6/13/23   Edward Speer    Add forgotten data segment
;     6/13/23   Edward Speer    Address critical code
;     6/14/23   Edward Speer    Cause music to play continuously
;     6/15/23   Edward Speer    Update comments

.cseg


;InitSoundVars
;
; Description:        This procedure initializes the variables needed to play 
;                     the game sounds (startup and win sounds) for the hexer
;                     game.
;
; Operation:          Sets the number of notes to currently be played at 0, the 
;                     current offset in the MusicTable to 0, and the eighth note 
;                     counter to 0 so that the first note will be played right 
;                     away when a sound is played
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None 
;
; Shared Variables:   NoteCounter (W) - a counter which upon reaching zero indicates
;                                   an eighth note of time has elapsed
;                     NotesToPlay (W) - a counter giving the number of notes which 
;                                   need to be played to complete the sound
;                     MusicOffset (W) - the offset to the sound currently being 
;                                   played in the music table
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16
; 
; Author:             Edward Speer
; Last Modified:      6/13/23

InitSoundVars:

        LDI   R16, 0
        STS   NoteCounter, R16    ;Note timing = 0 to play note right away 
        STS   NotesToPlay, R16    ;Currently no notes to be played 
        STS   MusicOffset, R16    ;Nothing to lookup in MusicTable

        RET                       ;All variables set so return


;SoundInterrupt
;
; Description:        This procedure is intended to be called at each milisecond 
;                     generated timer interrupt to play the sounds currently 
;                     required by the system. Plays no sound when game not 
;                     actively playing any music.
;
; Operation:          Checks the number of notes enqueued to be played for the
;                     sound being played by the system. If zero, plays nothing 
;                     on the speaker, if non-zero, plays the frequencies 
;                     designated in the music table at the rate of one frequency 
;                     per an eighth note for a rate of 120 bpm.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None 
;
; Shared Variables:   NoteCounter - (R/W) a counter which upon reaching zero indicates
;                                   an eighth note of time has elapsed
;                     NotesToPlay - (R/W) a counter giving the number of notes which 
;                                   need to be played to complete the sound
;                     MusicOffset - (R/W) the offset to the sound currently being 
;                                   played in the music table
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  None
; 
; Author:             Edward Speer
; Last Modified:      6/13/23

SoundInterrupt:

        PUSH   R12
		PUSH   R13
        PUSH   R15                 ;Save touched registers since called from
		PUSH   R16                 ; an interrupt handler, including those 
		PUSH   R17                 ; changed in PlayNote
		PUSH   R18
        PUSH   R19
		PUSH   R20
		PUSH   R21
		PUSH   R22
		PUSH   R23
		PUSH   R24                
        PUSH   ZL
        PUSH   ZH 

        LDS    R15, NotesToPlay 
        TST    R15
        BRNE   PlaySound            ;Otherwise play the necessary sound
		;BREQ   RepeatSound          ;if at end of music, repeat music

RepeatSound:

        LDS    R15, NotesInSound
		STS    NotesToPlay, R15      ;Reset the number of notes to the total 
		LDS    R19, OffsetToSound
		STS    MusicOffset, R19      ;and the offset to the start of the sound


PlaySound:

        LDS    R19, NoteCounter
        TST    R19 
        BRNE   Update8thCounter     ;If noteCounter not 0, still playing last note 
        ;BREQ  NextNote

NextNote:
    
        LDI    ZL, LOW(MusicTable << 1)   ;Get address of music table, shifted
        LDI    ZH, HIGH(MusicTable << 1)  ; for byte addressing 
        LDS    R13, MusicOffset           ;Get offset to next frequency to play in entries
        CLR    R12                        ;Use R12 for carry propogation 
        ADD    ZL, R13                    
        ADC    ZH, R12                    ;Move to next sound in MusicTable 
        LPM    R16, Z+
        LPM    R17, Z+                    ;Get next frequency in R17|R16 

		PUSH   R15                        ;Push registers changed in PlayNote

        RCALL  PlayNote                   ;And play it
		
		POP    R15                        ;Restore registers changed in PlayNote
		 
        INC    R13
		INC    R13                        ;Advance 2 bytes in the music table 
        STS    MusicOffset, R13           ;Set table offset to the next note
        DEC    R15
        STS    NotesToPlay, R15           ;One less note remaining to be played
        LDI    R19, (EIGHTH_TIME + 1)     ;Reset eighth note counter, +1 since about to dec

Update8thCounter:

        DEC    R19                        ;Count down miliseconds until next eighth note 
        STS    NoteCounter, R19           ;Update eighth note Timing counter 

SoundPlayed:

        POP    ZH                        ;Restore touched registers since called from 
        POP    ZL                        ; an interrupt handler
        POP    R24
        POP    R23 
        POP    R22 
        POP    R21
        POP    R20 
        POP    R19
		POP    R18
		POP    R17
		POP    R16
		POP    R15
		POP    R13
		POP    R12

        RET                               ;Correct sound played so return


;PlayStartupSound
;
; Description:        This procedure sets the shared sound variables so that 
;                     when caleld the sound interrupt routine will play the 
;                     startup sound for the Hexer game. Contains critical code 
;                     since the sound variables are edited and accessed in the 
;                     sound interrupt code.
;
; Operation:          Sets the Offset in the MusicTable to the begninning of the 
;                     startup sound, the number of notes to play to the number of 
;                     notes in the startup sound, and the eighth note timer
;                     counter to 0 to play the next note right away.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None 
;
; Shared Variables:   NoteCounter - (W) a counter which upon reaching zero indicates
;                                   an eighth note of time has elapsed
;                     NotesToPlay - (W) a counter giving the number of notes which 
;                                   need to be played to complete the sound
;                     MusicOffset - (W) the offset to the sound currently being 
;                                   played in the music table
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16
; 
; Author:             Edward Speer
; Last Modified:      6/13/23

PlayStartupSound:

        LDI    R16, START_OFFS
        IN     R0, SREG                ;Save current interrupt flag 
        CLI                            ;Critical code so disable interrupts
        STS    OffsetToSound, R16        ;Offset to startup sound in music table 

        LDI    R16, STARTUP_NOTES
        STS    NotesInSound, R16        ;Number of notes to play for startup
		
		LDI    R16, 0
		STS    NotesToPlay, R16        ;Stop current sound from playing 

        LDI    R16, 0                  ;Number of 8th notes to wait before next
        STS    EIGHTH_TIME, R16        ; note played

        OUT    SREG, R0                ;Restore status register including iterrupts 
        RET                            ;Done, so return 


;PlayWinSound
;
; Description:        This procedure sets the shared sound variables so that 
;                     when called the sound interrupt routine will play the 
;                     win sound for the Hexer game. Contains critical code 
;                     since the sound variables are edited and accessed in the 
;                     sound interrupt code.
;
; Operation:          Sets the Offset in the MusicTable to the beginning of the 
;                     win sound, the number of notes to play to the number of 
;                     notes in the win sound, and the eighth note timer
;                     counter to 0 to play the next note right away.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None 
;
; Shared Variables:   NoteCounter - (W) a counter which upon reaching zero indicates
;                                   an eighth note of time has elapsed
;                     NotesToPlay - (W) a counter giving the number of notes which 
;                                   need to be played to complete the sound
;                     MusicOffset - (W) the offset to the sound currently being 
;                                   played in the music table
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16
; 
; Author:             Edward Speer
; Last Modified:      6/13/23

PlayWinSound:

        LDI    R16, WIN_OFFS
        IN     R0, SREG                ;Save current interrupt flag 
        CLI                            ;Critical code so disable interrupts
        STS    OffsetToSound, R16      ;Offset to startup sound in music table 

        LDI    R16, WIN_NOTES
        STS    NotesInSound, R16       ;Number of notes to play for Winning sound

		LDI    R16, 0
		STS    NotesToPlay, R16        ;Stop current sound from playing

        LDI    R16, 0                  ;Number of 8th notes to wait before next
        STS    EIGHTH_TIME, R16        ; note played

        OUT    SREG, R0                ;Restore status register including iterrupts 
        RET                            ;Done, so return 


MusicTable:  ;Gives frequencies of eighth notes in game sounds. Each game sound 
             ; must end with a 0 to turn the speaker off after playing

        ;DW   ;Frequencies to play sound in order 

        .DW    880, 880, 1319, 1568, 1568, 1480, 1175, 988, 1319, 1760, 1760, 0
        .DW    1760, 1760, 2217, 2217, 2217, 2217, 0, 0, 1047, 1047, 1865, 1865, 1865, 1760, 1568 
		.DW    1397, 1319, 1245, 1245, 1245, 1245, 0, 0, 1047, 1047, 2093, 2093, 2093, 1865, 1760, 1568 
		.DW    1397, 1319, 1319, 1319, 1319, 0, 0, 1245, 1175, 1175, 1319, 1480, 1568, 1760
		.DW    1976, 2093, 2349, 2349, 2489, 2498, 0, 0, 1245, 1245, 1245, 1245, 1397, 1568
		.DW    1661, 1865, 2093, 2217, 2489, 2489, 2637, 2637, 0, 0
        .DW    392, 523, 659, 784, 1047, 1319, 1568, 1568, 1319, 0
        .DW    415, 523, 622, 831, 1047, 1245, 1661, 1661, 1245, 0
        .DW    466, 587, 698, 923, 1175, 1397, 1865, 1865, 0, 1865, 0, 1865
        .DW    2093, 0

;The data segment 

.dseg

NoteCounter:    .BYTE    1    ;Eighth note timing counter
NotesToPlay:    .BYTE    1    ;The number of notes to be played in current sound
MusicOffset:    .BYTE    1    ;Offset to current sound in the music table
NotesInSound:   .BYTE    1    ;Total number of notes in sound being played 
OffsetToSound:  .BYTE    1    ;Offset to the beginning of the current sound

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                 SPEAKER.INC                                ;
;                             Speaker Definitions                            ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the definitions needed for to play the game sounds for the 
; Hexer game, including the startup sound for the game and the win sound for the
; game.
;
; Revision History:
;     6/13/23   Edward Speer    Initial Revision
;     6/14/23   Edward Speer    Edit constants for longer music


;MusicTable constants

.EQU EIGHTH_TIME   = 254        ;Number of miliseconds per eighth note 

.EQU START_OFFS    = 0          ;Offset to start sound in music table 
.EQU WIN_OFFS      = 162        ;Offset to win sound in music table (in bytes)
.EQU STARTUP_NOTES = 81         ;Number of notes in the startup sound 
.EQU WIN_NOTES     = 34         ;Number of notes in the win sound

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                 SPEAKER.ASM                                ;
;                              Speaker Functions                             ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the functions necessary to play sounds on the speaker for
; the Microprocessor-Based Hexer game.
;
; Revision History:
;     6/3/23    Edward Speer    Initial Revision
;     6/13/23   Edward Speer    Set up arguments correctly for division 
;     6/16/23   Edward Speer    Update comments

.cseg


;InitSpeaker
;
; Description:        This procedure initializes the speaker such that the
;                     timer used to send signals to the speaker is turned off, 
;                     with the output on the timer compare register port set low 
;                     such that the speaker is not receiving current.
;
; Operation:          Sets the timer compare register for timer 1 such that the 
;                     timer is off and the output compare signal is low.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   None
;
; Input:              None
; Ouput:              Output timer controls to TCCR1A and TCCR1B
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  R16
; 
; Author:             Edward Speer
; Last Modified:      6/16/23

InitSpeaker:

        LDI  R16, OC_OFF
        OUT  TCCR1A, R16              ;Turn off output compare for timer1 

        LDI  R16, (CTC_ON | PRESC_8) 
        OUT  TCCR1B, R16              ;Turn on CTC mode, CLK/8 prescale on timer1

        LDI  R16, SP_LOW 
        OUT  PORTB, R16               ;Set signal out to speaker low

        RET                           ;Done, so return
    

; PlayNote
;
; Description:        This procedure plays a note at the passed frequency on the 
;                     speaker. The tone generated is a square wave, and it is 
;                     played until a new tone is triggered by a call to this 
;                     function. A call to this routine with argument of 0 will 
;                     result in turning off the speaker. 
;                     Frequency range: 20Hz-20kHz Hz
;
; Operation:          Check the frequency passed to ensure it is in the valid 
;                     frequency range, and if not, turn off the speaker. If 
;                     valid, set the output compare register for the timer and 
;                     reset the counter to output the square wave with the right
;                     frequency on the output compare port for timer 1.
;
; Arguments:          f (frequency to play) passed in R17|R16 (range 20Hz-20kHz)
; Return Value:       None
;
; Local Variables:    CountMax - the value to set the output compare register to
; Shared Variables:   None
;
; Input:              None
; Ouput:              Output timer controls to TCCR1A and TCCR1B, and output 
;                     the output compare value to OCRA1
;
; Error Handling:     Calls to the function with a frequency outside of the 
;                     frequency change result in turning off the speaker
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R18, R19, R20, R21, R22, R23, R24
; 
; Author:             Edward Speer
; Last Modified:      6/3/23

PlayNote: 

CheckMin: 

        LDI  R19, F_MIN_HIGH
        LDI  R18, F_MIN_LOW         ;Load minimum frequency
        CP   R16, R18 
        CPC  R17, R19               ;Compare f with minimum allowed frequency 
        BRLT SpeakerOff             ;If f < minimum, turn off speaker 
        ;BRGE CheckMax              ;Otherwise, check f below maximum

CheckMax:
        
        LDI  R18, LOW(F_MAX)
        LDI  R19, HIGH(F_MAX)       ;Load maximum frequency 
        CP   R16, R18 
        CPC  R17, R19               ;Compare f with maximum allowed frequency
        BRGE SpeakerOff             ;If f > maximum, turn off speaker 
        ;BRLT ComputeOC             ;Otherwise, go on to compute output compare 

ComputeOC:

        CLR  R24                     ;Set up args to divide: f in R24|R23|R22
		MOV  R23, R17
		MOV  R22, R16
        LDI  R19, LOW(SCALE_CONST)
        LDI  R20, BYTE2(SCALE_CONST) ;Load scale constant to perform division
        LDI  R21, BYTE3(SCALE_CONST)
        CALL Div24                   ;Perform division -> places OC in R20|R19 

SetOC:

        OUT  OCR1AH, R20             ;and high byte to output compare register
        OUT  OCR1AL, R19             ;Output low byte of output compare 

TimerOn:

        LDI  R16, OC1A_TOG
        OUT  TCCR1A, R16            ;Set toggle mode on for timer1
        RJMP NoteDone               ;And finished 

SpeakerOff:

        RCALL InitSpeaker           ;Reset speaker with timer off, pin low 

NoteDone:

        RET                         ;Done, so return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                   SWITCHES                                 ;
;                                Switch Routines                             ;
;                 Microprocessor-Based Hexer Game (AVR version)              ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the functions for debouncing the switches and getting the 
; switch status. The public functions included are:
;    InitSwitchVars  - Initialize variables for switch debouncing
;    DebounceSwitch  - Debounce the switch pattern on the 6 push switches and
;                      autorepeat
;    SwitchAvailable - Reset zero flag if a new switch pattern was debounced
;    GetSwitches     - Hold until pattern debounced, then return that pattern
;
;
; Revision History:
;    5/3/23    Edward Speer    Initial revision 
;    5/4/23    Edward Speer    Interrupt handler added, comments updated
;    5/5/23    Edward Speer    Debug double reporting of switch pressed
;    5/6/23    Edward Speer    Clean up documentation
;    6/13/23   Edward Speer    Remove extra event handler
;    6/13/23   Edward Speer    Increase auto-repeat time
;    6/14/23   Edward Speer    Debug issue storing debounce counter
;    6/16/23   Edward Speer    Update comments

.cseg


; InitSwitchVars
;
; Description:        This procedure initializes the switch debouncing 
;                     variables
; Operation:          The current switch pattern stored is reset to none 
;                     active and the NewPattern flag is reset
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   NewPattern (W) - flag indicating a new debounced pattern
;                                      available
;                     CurrPattern (W)- The most recently debounced switch pattern
;                                 
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  R16
; 
; Author:             Edward Speer
; Last Modified:      6/16/23

InitSwitchVars:

        LDI    R16, SWITCHES_OFF
        STS    PressedPattern, R16  ;Initalize pressed pattern to empty pattern
        LDI    R16, DEBOUNCE_TIME_LOW
		LDI    R17, DEBOUNCE_TIME_HIGH
        STS    DebCounter, R16      ;Initialize debounce counter to threshold
		STS    DebCounter+1, R17
        LDI    R16, SWITCHES_OFF
        STS    CurrPattern, R16     ;Set CurrPattern to all switches inactive 
        LDI    R16, 0x00
        STS    NewPattern, R16      ;Set NewPattern to false

        RET


; DebounceSwitch
;
; Description:        This procedure debounces the pressing of the push
;                     button switches. Expects to be called on every milisecond 
;                     timer interrupt. Includes 500 milisecond autorepeat.
; Operation:          If a new debounced pattern is available, then 
;                     CurrPattern is set to the pattern and SwitchAvailable is 
;                     set. Autorepeats switch presses held for 500 miliseconds
;                     after each subsequent press.
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    PressedPattern (Read/Write) - the switch pattern read on
;                                                   the most recent call of
;                                                   debouncing
;                     DebCounter (Read/Write) - the current count of calls for 
;                                               which the switch pattern has
;                                               been the same
; Shared Variables:   NewPattern (Write only) - flag indicating a new debounced 
;                                               pattern available
;                     CurrPattern (Write only) - The current debounced switch 
;                                                pattern
;
; Input:              The push button switch pattern detected from the 
;                     switches on bits 1-6 of port E
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         Debouncing filters button presses by using a timed 
;                     counter to ensure the button is pressed for a long
;                     enough time, by checking if the counter reaches a 
;                     threshold
; Data Structures:    CurrPattern is stored in bits 1-6 of 1 byte variable
;
; Registers Changed: None
; 
; Author:             Edward Speer
; Last Modified:      6/14/23

DebounceSwitch:

        PUSH   R15               ;Save touched registers, since expects to be 
        PUSH   R16               ; called during interrupt handling
        PUSH   R17
		PUSH   R18
		PUSH   R19
		PUSH   R20
		PUSH   R21
		PUSH   R22

        IN     R16, PINE         ;Read the pattern from IO to R16
        ANDI   R16, SWITCHES_OFF ;Mask the 8 bit IO reading to switch bits 1-6

CheckNoSwitches:

        CPI    R16, SWITCHES_OFF 
        BREQ   ResetDebounce     ;If all switch inactive, no signal to debounce
        ;BRNE  CheckPatternMatch ;Otherwise, debounce the pressed signal

CheckPatternMatch:
        
        LDS    R17, PressedPattern
        CP     R16, R17          ;Check buttons pressed match debouncing signal
        BRNE   ResetDebounce     ;If not, reset debouncing
        ;BREQ  DebounceCount     ;Otherwise, update/check counter

DebounceCount:

        LDS    R18, DebCounter      ;Load current debouncing counter 
		LDS    R19, DebCounter+1
		CLR    R20                  ;Clear R20 for carry propogation
		LDI    R21, 0x01
		SUB    R18, R21
		SBC    R19, R20             ;Decrement 16 bit counter by 1

CheckCounter:

        TST    R18
        BREQ   LowByte0          ;If counter has reached zero, pattern debounced 
        ;BRNE  RepeatMin         ;Otherwise, pattern not yet debounced

RepeatMin:

        LDI    R21, AR_TIME_BOT_LOW
		LDI    R22, AR_TIME_BOT_HIGH 
        CP     R21, R18
		CPC    R22, R19
        BRNE   NotDebounced      ;If the counter not reached minimum, do nothing
        ;BREQ  ARCounterReset    ;If counter reached minimum, reset for repeat 

ARCounterReset:

        LDI    R18, AR_TIME_TOP_LOW  ;Set counter to repeat top value
		LDI    R19, AT_TIME_TOP_HIGH

NotDebounced:

        STS    DebCounter, R18   ;Write debounce counter back to memory 
        RJMP   DebounceDone      ;Done running debouncer

LowByte0:

        TST    R19
		BRNE   RepeatMin         ;If counter not zero, then pattern not debounced 
		;BREQ  Debounced         ;Otherwise new pattern has debounced

Debounced:

        LDI    R16, 0x01
        STS    NewPattern, R16   ;Indicate new pattern is available
        STS    CurrPattern, R17  ;Update most recently debounced pattern
		STS    DebCounter,  R18  ;Update counter; begin autorepeat
		STS    DebCounter+1, R19
        RJMP   DebounceDone      ;Done running debouncer
        
ResetDebounce:
        
        STS   PressedPattern, R16 ;Store pressed pattern
		LDI   R17, DEBOUNCE_TIME_HIGH
        LDI   R16, DEBOUNCE_TIME_LOW
        STS   DebCounter, R16     ;Reset counter up to threshold
		STS   DebCounter+1,R17 
        ;RJMP DebounceDone        ;Done running debouncer 

DebounceDone:
       
        POP    R22                ;Restore touched registers
        POP    R21
        POP    R20
		POP    R19
		POP    R18
		POP    R17
		POP    R16
		POP    R15

        RET                       ;Done, so return


; SwitchAvailable
;
; Description:        This procedure determines whether or not a new debounced
;                     switch pattern is available.
; Operation:          If a new debounced pattern is available, then 
;                     the zero flag is reset, otherwise the zero flag is set
;
; Arguments:          None
; Return Value:       None
;
; Local Variables:    None
; Shared Variables:   NewPattern (Write only) - flag indicating a new debounced 
;                                               pattern
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  R16
; 
; Author:             Edward Speer
; Last Modified:      5/5/23

SwitchAvailable:

        LDS    R16, NewPattern  ;Get the current value of NewPattern 
        TST    R16              ;Set Zero flag if no new pattern available

SwitchAvailDone:

        RET                     ;We are done, so return


; GetSwitches
;
; Description:        This procedure blocks until a new switch pattern is 
;                     avaliable, then returns the new switch pattern.
;                     GetSwitches contains critical code and must block
;                     interrupts, as a new pattern should not be debounced 
;                     before GetSwitches resets the NewPattern flag.
; Operation:          If a new debounced pattern is available, then 
;                     the zero flag is reset, otherwise the zero flag is reset
;
; Arguments:          None
; Return Value:       The debounced switch pattern in R16
;
; Local Variables:    None
; Shared Variables:   CurrPattern (Read only)- The current debounced switch 
;                     pattern
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed:  R0, R16
; 
; Author:             Edward Speer
; Last Modified:      6/14/23

GetSwitches:

WaitSwitchLoop:

        RCALL    SwitchAvailable   ;Check if new debounced pattern is available
        BREQ     WaitSwitchLoop    ;Go back to top of function if no pattern 
        ;BRNE    NewSwitch         ;Otherwise, handle new switch available

NewSwitch:
        
        IN       R0, SREG          ;Save current interrupt flag status
        CLI                        ;Critical code so disable interrupts

        LDI      R16, 0x00
        STS      NewPattern, R16   ;Reset NewPattern to show no new pattern

        LDS      R16, CurrPattern  

        OUT      SREG, R0          ;Reset status register including interrupts

        RET                        ;New pattern returned in R16

; The data segment 

.dseg

; Shared switch pattern variables
NewPattern:     .BYTE    1    ;Flag indicating new debounced pattern available 
CurrPattern:    .BYTE    1    ;The most recently debounced switch pattern 
                             ;(bits 1-6)

; Local debouncing variables
PressedPattern: .BYTE    1    ;The pattern detected on Port E
DebCounter:     .BYTE    2    ;The number of clocks a pattern has been pressed

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                  SWTCH.INC                                 ;
;                              Switch Definitions                            ;
;                       Microprocessor-Based Hexer Game                      ;
;                                 Include File                               ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the definitions for the switch functions for the
; Microprocessor-Based Hexer game.
;
; Revision History:
;     5/3/23    Edward Speer    initial revision
;     5/4/23    Edward Speer    Add definitions for timer/port initialization
;     5/20/23   Edward Speer    Transfer IO constants to general inc file
;     5/20/23   Edward Speer    Update comments
;     6/13/23   Edward Speer    Add auto-repeat constants 

; Switch definitions 

; Timing parameters (assumes 1 ms interrupt)

.EQU    DEBOUNCE_TIME_LOW = 4           ;Threshold debouncing time in miliseconds byte 1
.EQU    DEBOUNCE_TIME_HIGH= 0           ;Threshold debouncing time in ms byte 2
.EQU    AR_TIME_BOT_LOW   = 0b00000000  ;Bottom value for auto-repeat counter (ms) byte 1
.EQU    AR_TIME_BOT_HIGH  = 0b10000000  ;Bottom value for auto-repeat counter byte 2
.EQU    AR_TIME_TOP_lOW   = 0b11111111  ;Top value for auto-repeat counter (ms) byte 1
.EQU    AT_TIME_TOP_HIGH  = 0b01111111  ;Top value for auto-repeat counter byte 2

; Hardware definitions

.EQU    SWITCHES_OFF = 0b01111110    ;Inactive state of the 6 switches 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                 UTILS.ASM                                  ;
;                              Utility Functions                             ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains some simple abstract utility functions needed for the
; microprocessor based hexer game
;
; Revision History:
;     6/3/23   Edward Speer    Initial Revision
;     6/13/23  Edward Speer    Add psuedo-random 16 bit number function 
;     6/16/23  Edward Speer    Update comments

.cseg


; Div24
;
; Description:        Performs integer division on 2 24 bit numbers
;
; Operation:          Takes in 2 24 bit numbers and returns the result of  
;                     integer division between them in R21|R20|R19
;
; Arguments:          24 bit dividend in R21|R20|R19, 
;                     24 bit divisor in R24|R23|R22
; Return Value:       24 bit division result in R21|R20|R19
;
; Local Variables:    None
; Shared Variables:   None
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         Euclid's division algorithm used to compute result
; Data Structures:    None
;
; Registers Changed:  R15, R16, R17, R25, R19, R20, R21, R22, R23, R24
; 
; Author:             Edward Speer
; Last Modified:      6/5/23

Div24:

    CLR  R15
    CLR  R16
    SUB  R17, R17     ;Clear registers for 24 bit remainder, clear carry flag
    LDI  R25, 25      ;Initialize for-loop counter

DivLoop:

    ROL  R19
    ROL  R20
    ROL  R21          ;Rotate dividend left 
    DEC  R25          ;Decrement for-loop counter
    BREQ DivDone      ;If counter is 0, we are done 
    ;BRNE CalcStep    ;Otherwise, perform the next step of division

CalcStep:

    ROL  R15
    ROL  R16
    ROL  R17          ;Shift dividend into remainder 
    SUB  R15, R22
    SBC  R16, R23
    SBC  R17, R24     ;Subtract divisor from remainder 
    BRCS RestRem      ;If result negative, restore remainder
    ;BRCC RepeatStep  ;Otherwise, repeat loop with carry to shift into result 

RepeatStep:

    SEC               ;Set carry to shift into result in next loop 
    RJMP  DivLoop     ;And restart for loop

RestRem:

    ADD  R15, R22
    ADC  R16, R23
    ADC  R17, R24     ;Restore remainder
    CLC               ;Clear carry for next loop iteration 
    RJMP DivLoop      ;And restart for loop 

DivDone:

    RET


; Random16No12
;
; Description:        Generates a 16 bit number with bit 12 masked out, 
;                     simulating randomness based on when the switch is pressed.
;                     Never returns a pattern with all 1's.
;
; Operation:          Generates a 16 bit number from the timer, then masks out  
;                     12. If the pattern was all 1's, regenerates a new pattern
;
; Arguments:          None
; Return Value:       16 bit number in R17|R16 with bit 12 0
;
; Local Variables:    None
;
; Shared Variables:   None
;
; Input:              None
; Ouput:              None
;
; Error Handling:     None
;
; Algorithms:         None
; Data Structures:    None
;
; Registers Changed: R16, R17, R18, R19
; 
; Author:             Edward Speer
; Last Modified:      6/11/23

Random16No12:

       IN     R16, TCNT1L        ;Use value of 16 bit timer as random - psuedo
	   IN     R17, TCNT1L        ; random depending on when user resets the game

       LDI    R18, ALL_ON_LOW
	   LDI    R19, ALL_ON_HIGH   ;Load mask to remove bit 12

	   AND    R16, R18
	   AND    R17, R19           ;Mask out bit 12 of the LEDs

	   LDI    R18, ALL_ON_LOW
	   LDI    R19, ALL_ON_HIGH

       CP     R16, R18
	   CPC    R17, R19
	   BREQ   Random16No12       ;If generated pattern with all 1's, regenerate
	   ;BRNE  Generated          ;Otherwise, done generating so return

       RET  
       
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                 SPEAKER.INC                                ;
;                             Speaker Definitions                            ;
;                       Microprocessor-Based Hexer Game                      ;
;                                                                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains the definitions needed for speaker control for the
; microprocessor-based hexer game
;
; Revision History:
;     6/3/23   Edward Speer    Initial Revision

; Timer Definitions 

.EQU   OC_OFF     = 0b00000000  ;Timer1 controlA to turn off OC on all channels 
.EQU   OC1A_TOG   = 0b01000000  ;Timer1 controlA, OC Toggle mode on on channel A
.EQU   CTC_ON     = 0b00001000  ;Timer1 controlB to turn on CTC mode
.EQU   PRESC_8    = 0b00000010  ;Timer1 controlB for clock over 8 prescaler 

; Speaker Port constants 

.EQU  SP_LOW      = 0b00000000  ;Speaker output pin low on port B

;Frequency constants

.EQU F_MIN_HIGH   = 0           ;High byte of min freq for carry propogation
.EQU F_MIN_LOW    = 20          ;Minimum frequency that may be played on speaker 
.EQU F_MAX        = 20000       ;Maximum frequency that may be played on speaker
.EQU SCALE_CONST  = 500000      ;CLK/(8 prescale * 2) used to compute OC
